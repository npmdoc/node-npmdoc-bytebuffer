<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a href="https://github.com/dcodeIO/bytebuffer.js#readme">bytebuffer (v5.0.1)</a>
</h1>
<h4>The swiss army knife for binary data in JavaScript.</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.bytebuffer">module bytebuffer</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">bytebuffer.</span>BIG_ENDIAN</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">bytebuffer.</span>DEFAULT_ENDIAN</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">bytebuffer.</span>DEFAULT_NOASSERT</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">bytebuffer.</span>LITTLE_ENDIAN</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.bytebuffer">
            function <span class="apidocSignatureSpan"></span>bytebuffer
            <span class="apidocSignatureSpan">(capacity, littleEndian, noAssert)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.Long">
            function <span class="apidocSignatureSpan">bytebuffer.</span>Long
            <span class="apidocSignatureSpan">(low, high, unsigned)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.accessor">
            function <span class="apidocSignatureSpan">bytebuffer.</span>accessor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.allocate">
            function <span class="apidocSignatureSpan">bytebuffer.</span>allocate
            <span class="apidocSignatureSpan">(capacity, littleEndian, noAssert)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.atob">
            function <span class="apidocSignatureSpan">bytebuffer.</span>atob
            <span class="apidocSignatureSpan">(b64)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.btoa">
            function <span class="apidocSignatureSpan">bytebuffer.</span>btoa
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.calculateString">
            function <span class="apidocSignatureSpan">bytebuffer.</span>calculateString
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.calculateUTF8Bytes">
            function <span class="apidocSignatureSpan">bytebuffer.</span>calculateUTF8Bytes
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.calculateUTF8Chars">
            function <span class="apidocSignatureSpan">bytebuffer.</span>calculateUTF8Chars
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.calculateVarint32">
            function <span class="apidocSignatureSpan">bytebuffer.</span>calculateVarint32
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.calculateVarint64">
            function <span class="apidocSignatureSpan">bytebuffer.</span>calculateVarint64
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.concat">
            function <span class="apidocSignatureSpan">bytebuffer.</span>concat
            <span class="apidocSignatureSpan">(buffers, encoding, littleEndian, noAssert)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.fromBase64">
            function <span class="apidocSignatureSpan">bytebuffer.</span>fromBase64
            <span class="apidocSignatureSpan">(str, littleEndian)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.fromBinary">
            function <span class="apidocSignatureSpan">bytebuffer.</span>fromBinary
            <span class="apidocSignatureSpan">(str, littleEndian)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.fromDebug">
            function <span class="apidocSignatureSpan">bytebuffer.</span>fromDebug
            <span class="apidocSignatureSpan">(str, littleEndian, noAssert)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.fromHex">
            function <span class="apidocSignatureSpan">bytebuffer.</span>fromHex
            <span class="apidocSignatureSpan">(str, littleEndian, noAssert)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.fromUTF8">
            function <span class="apidocSignatureSpan">bytebuffer.</span>fromUTF8
            <span class="apidocSignatureSpan">(str, littleEndian, noAssert)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.index">
            function <span class="apidocSignatureSpan">bytebuffer.</span>index
            <span class="apidocSignatureSpan">(capacity, littleEndian, noAssert)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.isByteBuffer">
            function <span class="apidocSignatureSpan">bytebuffer.</span>isByteBuffer
            <span class="apidocSignatureSpan">(bb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.type">
            function <span class="apidocSignatureSpan">bytebuffer.</span>type
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.wrap">
            function <span class="apidocSignatureSpan">bytebuffer.</span>wrap
            <span class="apidocSignatureSpan">(buffer, encoding, littleEndian, noAssert)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.zigZagDecode32">
            function <span class="apidocSignatureSpan">bytebuffer.</span>zigZagDecode32
            <span class="apidocSignatureSpan">(n)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.zigZagDecode64">
            function <span class="apidocSignatureSpan">bytebuffer.</span>zigZagDecode64
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.zigZagEncode32">
            function <span class="apidocSignatureSpan">bytebuffer.</span>zigZagEncode32
            <span class="apidocSignatureSpan">(n)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.zigZagEncode64">
            function <span class="apidocSignatureSpan">bytebuffer.</span>zigZagEncode64
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">bytebuffer.</span>DEFAULT_CAPACITY</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">bytebuffer.</span>MAX_VARINT32_BYTES</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">bytebuffer.</span>MAX_VARINT64_BYTES</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">bytebuffer.</span>Long.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">bytebuffer.</span>index.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">bytebuffer.</span>memcpy</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">bytebuffer.</span>METRICS_BYTES</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">bytebuffer.</span>METRICS_CHARS</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">bytebuffer.</span>VERSION</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.bytebuffer.Long">module bytebuffer.Long</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.Long.Long">
            function <span class="apidocSignatureSpan">bytebuffer.</span>Long
            <span class="apidocSignatureSpan">(low, high, unsigned)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.Long.fromBits">
            function <span class="apidocSignatureSpan">bytebuffer.Long.</span>fromBits
            <span class="apidocSignatureSpan">(lowBits, highBits, unsigned)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.Long.fromInt">
            function <span class="apidocSignatureSpan">bytebuffer.Long.</span>fromInt
            <span class="apidocSignatureSpan">(value, unsigned)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.Long.fromNumber">
            function <span class="apidocSignatureSpan">bytebuffer.Long.</span>fromNumber
            <span class="apidocSignatureSpan">(value, unsigned)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.Long.fromString">
            function <span class="apidocSignatureSpan">bytebuffer.Long.</span>fromString
            <span class="apidocSignatureSpan">(str, unsigned, radix)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.Long.fromValue">
            function <span class="apidocSignatureSpan">bytebuffer.Long.</span>fromValue
            <span class="apidocSignatureSpan">(val)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.Long.isLong">
            function <span class="apidocSignatureSpan">bytebuffer.Long.</span>isLong
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">bytebuffer.Long.</span>MAX_UNSIGNED_VALUE</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">bytebuffer.Long.</span>MAX_VALUE</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">bytebuffer.Long.</span>MIN_VALUE</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">bytebuffer.Long.</span>NEG_ONE</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">bytebuffer.Long.</span>ONE</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">bytebuffer.Long.</span>UONE</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">bytebuffer.Long.</span>UZERO</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">bytebuffer.Long.</span>ZERO</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.bytebuffer.Long.prototype">module bytebuffer.Long.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.Long.prototype.add">
            function <span class="apidocSignatureSpan">bytebuffer.Long.prototype.</span>add
            <span class="apidocSignatureSpan">(addend)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.Long.prototype.and">
            function <span class="apidocSignatureSpan">bytebuffer.Long.prototype.</span>and
            <span class="apidocSignatureSpan">(other)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.Long.prototype.comp">
            function <span class="apidocSignatureSpan">bytebuffer.Long.prototype.</span>comp
            <span class="apidocSignatureSpan">(other)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.Long.prototype.compare">
            function <span class="apidocSignatureSpan">bytebuffer.Long.prototype.</span>compare
            <span class="apidocSignatureSpan">(other)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.Long.prototype.div">
            function <span class="apidocSignatureSpan">bytebuffer.Long.prototype.</span>div
            <span class="apidocSignatureSpan">(divisor)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.Long.prototype.divide">
            function <span class="apidocSignatureSpan">bytebuffer.Long.prototype.</span>divide
            <span class="apidocSignatureSpan">(divisor)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.Long.prototype.eq">
            function <span class="apidocSignatureSpan">bytebuffer.Long.prototype.</span>eq
            <span class="apidocSignatureSpan">(other)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.Long.prototype.equals">
            function <span class="apidocSignatureSpan">bytebuffer.Long.prototype.</span>equals
            <span class="apidocSignatureSpan">(other)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.Long.prototype.getHighBits">
            function <span class="apidocSignatureSpan">bytebuffer.Long.prototype.</span>getHighBits
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.Long.prototype.getHighBitsUnsigned">
            function <span class="apidocSignatureSpan">bytebuffer.Long.prototype.</span>getHighBitsUnsigned
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.Long.prototype.getLowBits">
            function <span class="apidocSignatureSpan">bytebuffer.Long.prototype.</span>getLowBits
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.Long.prototype.getLowBitsUnsigned">
            function <span class="apidocSignatureSpan">bytebuffer.Long.prototype.</span>getLowBitsUnsigned
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.Long.prototype.getNumBitsAbs">
            function <span class="apidocSignatureSpan">bytebuffer.Long.prototype.</span>getNumBitsAbs
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.Long.prototype.greaterThan">
            function <span class="apidocSignatureSpan">bytebuffer.Long.prototype.</span>greaterThan
            <span class="apidocSignatureSpan">(other)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.Long.prototype.greaterThanOrEqual">
            function <span class="apidocSignatureSpan">bytebuffer.Long.prototype.</span>greaterThanOrEqual
            <span class="apidocSignatureSpan">(other)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.Long.prototype.gt">
            function <span class="apidocSignatureSpan">bytebuffer.Long.prototype.</span>gt
            <span class="apidocSignatureSpan">(other)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.Long.prototype.gte">
            function <span class="apidocSignatureSpan">bytebuffer.Long.prototype.</span>gte
            <span class="apidocSignatureSpan">(other)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.Long.prototype.isEven">
            function <span class="apidocSignatureSpan">bytebuffer.Long.prototype.</span>isEven
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.Long.prototype.isNegative">
            function <span class="apidocSignatureSpan">bytebuffer.Long.prototype.</span>isNegative
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.Long.prototype.isOdd">
            function <span class="apidocSignatureSpan">bytebuffer.Long.prototype.</span>isOdd
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.Long.prototype.isPositive">
            function <span class="apidocSignatureSpan">bytebuffer.Long.prototype.</span>isPositive
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.Long.prototype.isZero">
            function <span class="apidocSignatureSpan">bytebuffer.Long.prototype.</span>isZero
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.Long.prototype.lessThan">
            function <span class="apidocSignatureSpan">bytebuffer.Long.prototype.</span>lessThan
            <span class="apidocSignatureSpan">(other)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.Long.prototype.lessThanOrEqual">
            function <span class="apidocSignatureSpan">bytebuffer.Long.prototype.</span>lessThanOrEqual
            <span class="apidocSignatureSpan">(other)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.Long.prototype.lt">
            function <span class="apidocSignatureSpan">bytebuffer.Long.prototype.</span>lt
            <span class="apidocSignatureSpan">(other)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.Long.prototype.lte">
            function <span class="apidocSignatureSpan">bytebuffer.Long.prototype.</span>lte
            <span class="apidocSignatureSpan">(other)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.Long.prototype.mod">
            function <span class="apidocSignatureSpan">bytebuffer.Long.prototype.</span>mod
            <span class="apidocSignatureSpan">(divisor)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.Long.prototype.modulo">
            function <span class="apidocSignatureSpan">bytebuffer.Long.prototype.</span>modulo
            <span class="apidocSignatureSpan">(divisor)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.Long.prototype.mul">
            function <span class="apidocSignatureSpan">bytebuffer.Long.prototype.</span>mul
            <span class="apidocSignatureSpan">(multiplier)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.Long.prototype.multiply">
            function <span class="apidocSignatureSpan">bytebuffer.Long.prototype.</span>multiply
            <span class="apidocSignatureSpan">(multiplier)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.Long.prototype.neg">
            function <span class="apidocSignatureSpan">bytebuffer.Long.prototype.</span>neg
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.Long.prototype.negate">
            function <span class="apidocSignatureSpan">bytebuffer.Long.prototype.</span>negate
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.Long.prototype.neq">
            function <span class="apidocSignatureSpan">bytebuffer.Long.prototype.</span>neq
            <span class="apidocSignatureSpan">(other)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.Long.prototype.not">
            function <span class="apidocSignatureSpan">bytebuffer.Long.prototype.</span>not
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.Long.prototype.notEquals">
            function <span class="apidocSignatureSpan">bytebuffer.Long.prototype.</span>notEquals
            <span class="apidocSignatureSpan">(other)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.Long.prototype.or">
            function <span class="apidocSignatureSpan">bytebuffer.Long.prototype.</span>or
            <span class="apidocSignatureSpan">(other)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.Long.prototype.shiftLeft">
            function <span class="apidocSignatureSpan">bytebuffer.Long.prototype.</span>shiftLeft
            <span class="apidocSignatureSpan">(numBits)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.Long.prototype.shiftRight">
            function <span class="apidocSignatureSpan">bytebuffer.Long.prototype.</span>shiftRight
            <span class="apidocSignatureSpan">(numBits)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.Long.prototype.shiftRightUnsigned">
            function <span class="apidocSignatureSpan">bytebuffer.Long.prototype.</span>shiftRightUnsigned
            <span class="apidocSignatureSpan">(numBits)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.Long.prototype.shl">
            function <span class="apidocSignatureSpan">bytebuffer.Long.prototype.</span>shl
            <span class="apidocSignatureSpan">(numBits)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.Long.prototype.shr">
            function <span class="apidocSignatureSpan">bytebuffer.Long.prototype.</span>shr
            <span class="apidocSignatureSpan">(numBits)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.Long.prototype.shru">
            function <span class="apidocSignatureSpan">bytebuffer.Long.prototype.</span>shru
            <span class="apidocSignatureSpan">(numBits)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.Long.prototype.sub">
            function <span class="apidocSignatureSpan">bytebuffer.Long.prototype.</span>sub
            <span class="apidocSignatureSpan">(subtrahend)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.Long.prototype.subtract">
            function <span class="apidocSignatureSpan">bytebuffer.Long.prototype.</span>subtract
            <span class="apidocSignatureSpan">(subtrahend)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.Long.prototype.toBytes">
            function <span class="apidocSignatureSpan">bytebuffer.Long.prototype.</span>toBytes
            <span class="apidocSignatureSpan">(le)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.Long.prototype.toBytesBE">
            function <span class="apidocSignatureSpan">bytebuffer.Long.prototype.</span>toBytesBE
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.Long.prototype.toBytesLE">
            function <span class="apidocSignatureSpan">bytebuffer.Long.prototype.</span>toBytesLE
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.Long.prototype.toInt">
            function <span class="apidocSignatureSpan">bytebuffer.Long.prototype.</span>toInt
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.Long.prototype.toNumber">
            function <span class="apidocSignatureSpan">bytebuffer.Long.prototype.</span>toNumber
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.Long.prototype.toSigned">
            function <span class="apidocSignatureSpan">bytebuffer.Long.prototype.</span>toSigned
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.Long.prototype.toString">
            function <span class="apidocSignatureSpan">bytebuffer.Long.prototype.</span>toString
            <span class="apidocSignatureSpan">(radix)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.Long.prototype.toUnsigned">
            function <span class="apidocSignatureSpan">bytebuffer.Long.prototype.</span>toUnsigned
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.Long.prototype.xor">
            function <span class="apidocSignatureSpan">bytebuffer.Long.prototype.</span>xor
            <span class="apidocSignatureSpan">(other)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.bytebuffer.index">module bytebuffer.index</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">bytebuffer.index.</span>BIG_ENDIAN</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">bytebuffer.index.</span>DEFAULT_ENDIAN</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">bytebuffer.index.</span>DEFAULT_NOASSERT</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">bytebuffer.index.</span>LITTLE_ENDIAN</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.index.index">
            function <span class="apidocSignatureSpan">bytebuffer.</span>index
            <span class="apidocSignatureSpan">(capacity, littleEndian, noAssert)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.index.Long">
            function <span class="apidocSignatureSpan">bytebuffer.index.</span>Long
            <span class="apidocSignatureSpan">(low, high, unsigned)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.index.accessor">
            function <span class="apidocSignatureSpan">bytebuffer.index.</span>accessor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.index.allocate">
            function <span class="apidocSignatureSpan">bytebuffer.index.</span>allocate
            <span class="apidocSignatureSpan">(capacity, littleEndian, noAssert)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.index.atob">
            function <span class="apidocSignatureSpan">bytebuffer.index.</span>atob
            <span class="apidocSignatureSpan">(b64)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.index.btoa">
            function <span class="apidocSignatureSpan">bytebuffer.index.</span>btoa
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.index.calculateString">
            function <span class="apidocSignatureSpan">bytebuffer.index.</span>calculateString
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.index.calculateUTF8Bytes">
            function <span class="apidocSignatureSpan">bytebuffer.index.</span>calculateUTF8Bytes
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.index.calculateUTF8Chars">
            function <span class="apidocSignatureSpan">bytebuffer.index.</span>calculateUTF8Chars
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.index.calculateVarint32">
            function <span class="apidocSignatureSpan">bytebuffer.index.</span>calculateVarint32
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.index.calculateVarint64">
            function <span class="apidocSignatureSpan">bytebuffer.index.</span>calculateVarint64
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.index.concat">
            function <span class="apidocSignatureSpan">bytebuffer.index.</span>concat
            <span class="apidocSignatureSpan">(buffers, encoding, littleEndian, noAssert)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.index.fromBase64">
            function <span class="apidocSignatureSpan">bytebuffer.index.</span>fromBase64
            <span class="apidocSignatureSpan">(str, littleEndian)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.index.fromBinary">
            function <span class="apidocSignatureSpan">bytebuffer.index.</span>fromBinary
            <span class="apidocSignatureSpan">(str, littleEndian)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.index.fromDebug">
            function <span class="apidocSignatureSpan">bytebuffer.index.</span>fromDebug
            <span class="apidocSignatureSpan">(str, littleEndian, noAssert)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.index.fromHex">
            function <span class="apidocSignatureSpan">bytebuffer.index.</span>fromHex
            <span class="apidocSignatureSpan">(str, littleEndian, noAssert)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.index.fromUTF8">
            function <span class="apidocSignatureSpan">bytebuffer.index.</span>fromUTF8
            <span class="apidocSignatureSpan">(str, littleEndian, noAssert)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.index.isByteBuffer">
            function <span class="apidocSignatureSpan">bytebuffer.index.</span>isByteBuffer
            <span class="apidocSignatureSpan">(bb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.index.type">
            function <span class="apidocSignatureSpan">bytebuffer.index.</span>type
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.index.wrap">
            function <span class="apidocSignatureSpan">bytebuffer.index.</span>wrap
            <span class="apidocSignatureSpan">(buffer, encoding, littleEndian, noAssert)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.index.zigZagDecode32">
            function <span class="apidocSignatureSpan">bytebuffer.index.</span>zigZagDecode32
            <span class="apidocSignatureSpan">(n)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.index.zigZagDecode64">
            function <span class="apidocSignatureSpan">bytebuffer.index.</span>zigZagDecode64
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.index.zigZagEncode32">
            function <span class="apidocSignatureSpan">bytebuffer.index.</span>zigZagEncode32
            <span class="apidocSignatureSpan">(n)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.index.zigZagEncode64">
            function <span class="apidocSignatureSpan">bytebuffer.index.</span>zigZagEncode64
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">bytebuffer.index.</span>DEFAULT_CAPACITY</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">bytebuffer.index.</span>MAX_VARINT32_BYTES</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">bytebuffer.index.</span>MAX_VARINT64_BYTES</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">bytebuffer.index.</span>memcpy</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">bytebuffer.index.</span>METRICS_BYTES</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">bytebuffer.index.</span>METRICS_CHARS</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">bytebuffer.index.</span>VERSION</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.bytebuffer.index.prototype">module bytebuffer.index.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.index.prototype.BE">
            function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>BE
            <span class="apidocSignatureSpan">(bigEndian)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.index.prototype.LE">
            function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>LE
            <span class="apidocSignatureSpan">(littleEndian)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.index.prototype.append">
            function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>append
            <span class="apidocSignatureSpan">(source, encoding, offset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.index.prototype.appendTo">
            function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>appendTo
            <span class="apidocSignatureSpan">(target, offset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.index.prototype.assert">
            function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>assert
            <span class="apidocSignatureSpan">(assert)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.index.prototype.capacity">
            function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>capacity
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.index.prototype.clear">
            function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>clear
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.index.prototype.clone">
            function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>clone
            <span class="apidocSignatureSpan">(copy)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.index.prototype.compact">
            function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>compact
            <span class="apidocSignatureSpan">(begin, end)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.index.prototype.copy">
            function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>copy
            <span class="apidocSignatureSpan">(begin, end)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.index.prototype.copyTo">
            function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>copyTo
            <span class="apidocSignatureSpan">(target, targetOffset, sourceOffset, sourceLimit)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.index.prototype.ensureCapacity">
            function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>ensureCapacity
            <span class="apidocSignatureSpan">(capacity)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.index.prototype.fill">
            function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>fill
            <span class="apidocSignatureSpan">(value, begin, end)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.index.prototype.flip">
            function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>flip
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.index.prototype.mark">
            function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>mark
            <span class="apidocSignatureSpan">(offset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.index.prototype.order">
            function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>order
            <span class="apidocSignatureSpan">(littleEndian)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.index.prototype.prepend">
            function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>prepend
            <span class="apidocSignatureSpan">(source, encoding, offset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.index.prototype.prependTo">
            function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>prependTo
            <span class="apidocSignatureSpan">(target, offset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.index.prototype.printDebug">
            function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>printDebug
            <span class="apidocSignatureSpan">(out)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.index.prototype.readBitSet">
            function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>readBitSet
            <span class="apidocSignatureSpan">(offset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.index.prototype.readByte">
            function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>readByte
            <span class="apidocSignatureSpan">(offset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.index.prototype.readBytes">
            function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>readBytes
            <span class="apidocSignatureSpan">(length, offset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.index.prototype.readCString">
            function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>readCString
            <span class="apidocSignatureSpan">(offset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.index.prototype.readDouble">
            function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>readDouble
            <span class="apidocSignatureSpan">(offset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.index.prototype.readFloat">
            function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>readFloat
            <span class="apidocSignatureSpan">(offset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.index.prototype.readFloat32">
            function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>readFloat32
            <span class="apidocSignatureSpan">(offset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.index.prototype.readFloat64">
            function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>readFloat64
            <span class="apidocSignatureSpan">(offset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.index.prototype.readIString">
            function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>readIString
            <span class="apidocSignatureSpan">(offset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.index.prototype.readInt">
            function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>readInt
            <span class="apidocSignatureSpan">(offset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.index.prototype.readInt16">
            function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>readInt16
            <span class="apidocSignatureSpan">(offset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.index.prototype.readInt32">
            function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>readInt32
            <span class="apidocSignatureSpan">(offset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.index.prototype.readInt64">
            function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>readInt64
            <span class="apidocSignatureSpan">(offset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.index.prototype.readInt8">
            function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>readInt8
            <span class="apidocSignatureSpan">(offset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.index.prototype.readLong">
            function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>readLong
            <span class="apidocSignatureSpan">(offset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.index.prototype.readShort">
            function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>readShort
            <span class="apidocSignatureSpan">(offset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.index.prototype.readString">
            function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>readString
            <span class="apidocSignatureSpan">(length, metrics, offset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.index.prototype.readUInt16">
            function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>readUInt16
            <span class="apidocSignatureSpan">(offset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.index.prototype.readUInt32">
            function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>readUInt32
            <span class="apidocSignatureSpan">(offset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.index.prototype.readUInt64">
            function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>readUInt64
            <span class="apidocSignatureSpan">(offset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.index.prototype.readUInt8">
            function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>readUInt8
            <span class="apidocSignatureSpan">(offset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.index.prototype.readUTF8String">
            function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>readUTF8String
            <span class="apidocSignatureSpan">(length, metrics, offset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.index.prototype.readUint16">
            function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>readUint16
            <span class="apidocSignatureSpan">(offset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.index.prototype.readUint32">
            function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>readUint32
            <span class="apidocSignatureSpan">(offset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.index.prototype.readUint64">
            function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>readUint64
            <span class="apidocSignatureSpan">(offset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.index.prototype.readUint8">
            function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>readUint8
            <span class="apidocSignatureSpan">(offset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.index.prototype.readVString">
            function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>readVString
            <span class="apidocSignatureSpan">(offset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.index.prototype.readVarint32">
            function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>readVarint32
            <span class="apidocSignatureSpan">(offset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.index.prototype.readVarint32ZigZag">
            function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>readVarint32ZigZag
            <span class="apidocSignatureSpan">(offset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.index.prototype.readVarint64">
            function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>readVarint64
            <span class="apidocSignatureSpan">(offset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.index.prototype.readVarint64ZigZag">
            function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>readVarint64ZigZag
            <span class="apidocSignatureSpan">(offset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.index.prototype.remaining">
            function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>remaining
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.index.prototype.reset">
            function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>reset
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.index.prototype.resize">
            function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>resize
            <span class="apidocSignatureSpan">(capacity)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.index.prototype.reverse">
            function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>reverse
            <span class="apidocSignatureSpan">(begin, end)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.index.prototype.skip">
            function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>skip
            <span class="apidocSignatureSpan">(length)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.index.prototype.slice">
            function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>slice
            <span class="apidocSignatureSpan">(begin, end)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.index.prototype.toArrayBuffer">
            function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>toArrayBuffer
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.index.prototype.toBase64">
            function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>toBase64
            <span class="apidocSignatureSpan">(begin, end)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.index.prototype.toBinary">
            function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>toBinary
            <span class="apidocSignatureSpan">(begin, end)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.index.prototype.toBuffer">
            function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>toBuffer
            <span class="apidocSignatureSpan">(forceCopy)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.index.prototype.toDebug">
            function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>toDebug
            <span class="apidocSignatureSpan">(columns)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.index.prototype.toHex">
            function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>toHex
            <span class="apidocSignatureSpan">(begin, end)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.index.prototype.toString">
            function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>toString
            <span class="apidocSignatureSpan">(encoding, begin, end)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.index.prototype.toUTF8">
            function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>toUTF8
            <span class="apidocSignatureSpan">(begin, end)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.index.prototype.writeBitSet">
            function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>writeBitSet
            <span class="apidocSignatureSpan">(value, offset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.index.prototype.writeByte">
            function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>writeByte
            <span class="apidocSignatureSpan">(value, offset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.index.prototype.writeCString">
            function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>writeCString
            <span class="apidocSignatureSpan">(str, offset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.index.prototype.writeDouble">
            function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>writeDouble
            <span class="apidocSignatureSpan">(value, offset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.index.prototype.writeFloat">
            function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>writeFloat
            <span class="apidocSignatureSpan">(value, offset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.index.prototype.writeFloat32">
            function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>writeFloat32
            <span class="apidocSignatureSpan">(value, offset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.index.prototype.writeFloat64">
            function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>writeFloat64
            <span class="apidocSignatureSpan">(value, offset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.index.prototype.writeIString">
            function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>writeIString
            <span class="apidocSignatureSpan">(str, offset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.index.prototype.writeInt">
            function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>writeInt
            <span class="apidocSignatureSpan">(value, offset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.index.prototype.writeInt16">
            function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>writeInt16
            <span class="apidocSignatureSpan">(value, offset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.index.prototype.writeInt32">
            function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>writeInt32
            <span class="apidocSignatureSpan">(value, offset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.index.prototype.writeInt64">
            function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>writeInt64
            <span class="apidocSignatureSpan">(value, offset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.index.prototype.writeInt8">
            function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>writeInt8
            <span class="apidocSignatureSpan">(value, offset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.index.prototype.writeLong">
            function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>writeLong
            <span class="apidocSignatureSpan">(value, offset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.index.prototype.writeShort">
            function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>writeShort
            <span class="apidocSignatureSpan">(value, offset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.index.prototype.writeString">
            function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>writeString
            <span class="apidocSignatureSpan">(str, offset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.index.prototype.writeUInt16">
            function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>writeUInt16
            <span class="apidocSignatureSpan">(value, offset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.index.prototype.writeUInt32">
            function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>writeUInt32
            <span class="apidocSignatureSpan">(value, offset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.index.prototype.writeUInt64">
            function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>writeUInt64
            <span class="apidocSignatureSpan">(value, offset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.index.prototype.writeUInt8">
            function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>writeUInt8
            <span class="apidocSignatureSpan">(value, offset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.index.prototype.writeUTF8String">
            function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>writeUTF8String
            <span class="apidocSignatureSpan">(str, offset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.index.prototype.writeUint16">
            function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>writeUint16
            <span class="apidocSignatureSpan">(value, offset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.index.prototype.writeUint32">
            function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>writeUint32
            <span class="apidocSignatureSpan">(value, offset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.index.prototype.writeUint64">
            function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>writeUint64
            <span class="apidocSignatureSpan">(value, offset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.index.prototype.writeUint8">
            function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>writeUint8
            <span class="apidocSignatureSpan">(value, offset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.index.prototype.writeVString">
            function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>writeVString
            <span class="apidocSignatureSpan">(str, offset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.index.prototype.writeVarint32">
            function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>writeVarint32
            <span class="apidocSignatureSpan">(value, offset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.index.prototype.writeVarint32ZigZag">
            function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>writeVarint32ZigZag
            <span class="apidocSignatureSpan">(value, offset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.index.prototype.writeVarint64">
            function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>writeVarint64
            <span class="apidocSignatureSpan">(value, offset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bytebuffer.index.prototype.writeVarint64ZigZag">
            function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>writeVarint64ZigZag
            <span class="apidocSignatureSpan">(value, offset)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.bytebuffer" id="apidoc.module.bytebuffer">module bytebuffer</a></h1>










    <h2>
        <a href="#apidoc.element.bytebuffer.bytebuffer" id="apidoc.element.bytebuffer.bytebuffer">
        function <span class="apidocSignatureSpan"></span>bytebuffer
        <span class="apidocSignatureSpan">(capacity, littleEndian, noAssert)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bytebuffer = function (capacity, littleEndian, noAssert) {
    if (typeof capacity === 'undefined')
        capacity = ByteBuffer.DEFAULT_CAPACITY;
    if (typeof littleEndian === 'undefined')
        littleEndian = ByteBuffer.DEFAULT_ENDIAN;
    if (typeof noAssert === 'undefined')
        noAssert = ByteBuffer.DEFAULT_NOASSERT;
    if (!noAssert) {
        capacity = capacity | 0;
        if (capacity &lt; 0)
            throw RangeError("Illegal capacity");
        littleEndian = !!littleEndian;
        noAssert = !!noAssert;
    }

    /**
     * Backing node Buffer.
     * @type {!Buffer}
     * @expose
     */
    this.buffer = capacity === 0 ? EMPTY_BUFFER : new Buffer(capacity);

    /**
     * Absolute read/write offset.
     * @type {number}
     * @expose
     * @see ByteBuffer#flip
     * @see ByteBuffer#clear
     */
    this.offset = 0;

    /**
     * Marked offset.
     * @type {number}
     * @expose
     * @see ByteBuffer#mark
     * @see ByteBuffer#reset
     */
    this.markedOffset = -1;

    /**
     * Absolute limit of the contained data. Set to the backing buffer's capacity upon allocation.
     * @type {number}
     * @expose
     * @see ByteBuffer#flip
     * @see ByteBuffer#clear
     */
    this.limit = capacity;

    /**
     * Whether to use little endian byte order, defaults to `false` for big endian.
     * @type {boolean}
     * @expose
     */
    this.littleEndian = littleEndian;

    /**
     * Whether to skip assertions of offsets and values, defaults to `false`.
     * @type {boolean}
     * @expose
     */
    this.noAssert = noAssert;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.Long" id="apidoc.element.bytebuffer.Long">
        function <span class="apidocSignatureSpan">bytebuffer.</span>Long
        <span class="apidocSignatureSpan">(low, high, unsigned)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Long(low, high, unsigned) {

    /**
     * The low 32 bits as a signed value.
     * @type {number}
     */
    this.low = low | 0;

    /**
     * The high 32 bits as a signed value.
     * @type {number}
     */
    this.high = high | 0;

    /**
     * Whether unsigned or not.
     * @type {boolean}
     */
    this.unsigned = !!unsigned;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.accessor" id="apidoc.element.bytebuffer.accessor">
        function <span class="apidocSignatureSpan">bytebuffer.</span>accessor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">accessor = function () {
    return Buffer;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.allocate" id="apidoc.element.bytebuffer.allocate">
        function <span class="apidocSignatureSpan">bytebuffer.</span>allocate
        <span class="apidocSignatureSpan">(capacity, littleEndian, noAssert)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">allocate = function (capacity, littleEndian, noAssert) {
    return new ByteBuffer(capacity, littleEndian, noAssert);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.atob" id="apidoc.element.bytebuffer.atob">
        function <span class="apidocSignatureSpan">bytebuffer.</span>atob
        <span class="apidocSignatureSpan">(b64)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">atob = function (b64) {
    return ByteBuffer.fromBase64(b64).toBinary();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.btoa" id="apidoc.element.bytebuffer.btoa">
        function <span class="apidocSignatureSpan">bytebuffer.</span>btoa
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">btoa = function (str) {
    return ByteBuffer.fromBinary(str).toBase64();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.calculateString" id="apidoc.element.bytebuffer.calculateString">
        function <span class="apidocSignatureSpan">bytebuffer.</span>calculateString
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">calculateString = function (str) {
    if (typeof str !== 'string')
        throw TypeError("Illegal argument: "+(typeof str));
    return Buffer.byteLength(str, "utf8");
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.calculateUTF8Bytes" id="apidoc.element.bytebuffer.calculateUTF8Bytes">
        function <span class="apidocSignatureSpan">bytebuffer.</span>calculateUTF8Bytes
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">calculateUTF8Bytes = function (str) {
    if (typeof str !== 'string')
        throw TypeError("Illegal argument: "+(typeof str));
    return Buffer.byteLength(str, "utf8");
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.calculateUTF8Chars" id="apidoc.element.bytebuffer.calculateUTF8Chars">
        function <span class="apidocSignatureSpan">bytebuffer.</span>calculateUTF8Chars
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">calculateUTF8Chars = function (str) {
    return utfx.calculateUTF16asUTF8(stringSource(str))[0];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.calculateVarint32" id="apidoc.element.bytebuffer.calculateVarint32">
        function <span class="apidocSignatureSpan">bytebuffer.</span>calculateVarint32
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">calculateVarint32 = function (value) {
    // ref: src/google/protobuf/io/coded_stream.cc
    value = value &gt;&gt;&gt; 0;
         if (value &lt; 1 &lt;&lt; 7 ) return 1;
    else if (value &lt; 1 &lt;&lt; 14) return 2;
    else if (value &lt; 1 &lt;&lt; 21) return 3;
    else if (value &lt; 1 &lt;&lt; 28) return 4;
    else                      return 5;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.calculateVarint64" id="apidoc.element.bytebuffer.calculateVarint64">
        function <span class="apidocSignatureSpan">bytebuffer.</span>calculateVarint64
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">calculateVarint64 = function (value) {
    if (typeof value === 'number')
        value = Long.fromNumber(value);
    else if (typeof value === 'string')
        value = Long.fromString(value);
    // ref: src/google/protobuf/io/coded_stream.cc
    var part0 = value.toInt() &gt;&gt;&gt; 0,
        part1 = value.shiftRightUnsigned(28).toInt() &gt;&gt;&gt; 0,
        part2 = value.shiftRightUnsigned(56).toInt() &gt;&gt;&gt; 0;
    if (part2 == 0) {
        if (part1 == 0) {
            if (part0 &lt; 1 &lt;&lt; 14)
                return part0 &lt; 1 &lt;&lt; 7 ? 1 : 2;
            else
                return part0 &lt; 1 &lt;&lt; 21 ? 3 : 4;
        } else {
            if (part1 &lt; 1 &lt;&lt; 14)
                return part1 &lt; 1 &lt;&lt; 7 ? 5 : 6;
            else
                return part1 &lt; 1 &lt;&lt; 21 ? 7 : 8;
        }
    } else
        return part2 &lt; 1 &lt;&lt; 7 ? 9 : 10;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.concat" id="apidoc.element.bytebuffer.concat">
        function <span class="apidocSignatureSpan">bytebuffer.</span>concat
        <span class="apidocSignatureSpan">(buffers, encoding, littleEndian, noAssert)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">concat = function (buffers, encoding, littleEndian, noAssert) {
    if (typeof encoding === 'boolean' || typeof encoding !== 'string') {
        noAssert = littleEndian;
        littleEndian = encoding;
        encoding = undefined;
    }
    var capacity = 0;
    for (var i=0, k=buffers.length, length; i&lt;k; ++i) {
        if (!ByteBuffer.isByteBuffer(buffers[i]))
            buffers[i] = ByteBuffer.wrap(buffers[i], encoding);
        length = buffers[i].limit - buffers[i].offset;
        if (length &gt; 0) capacity += length;
    }
    if (capacity === 0)
        return new ByteBuffer(0, littleEndian, noAssert);
    var bb = new ByteBuffer(capacity, littleEndian, noAssert),
        bi;
    i=0; while (i&lt;k) {
        bi = buffers[i++];
        length = bi.limit - bi.offset;
        if (length &lt;= 0) continue;
        bi.buffer.copy(bb.buffer, bb.offset, bi.offset, bi.limit);
        bb.offset += length;
    }
    bb.limit = bb.offset;
    bb.offset = 0;
    return bb;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.fromBase64" id="apidoc.element.bytebuffer.fromBase64">
        function <span class="apidocSignatureSpan">bytebuffer.</span>fromBase64
        <span class="apidocSignatureSpan">(str, littleEndian)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fromBase64 = function (str, littleEndian) {
    return ByteBuffer.wrap(new Buffer(str, "base64"), littleEndian);
    return bb;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.fromBinary" id="apidoc.element.bytebuffer.fromBinary">
        function <span class="apidocSignatureSpan">bytebuffer.</span>fromBinary
        <span class="apidocSignatureSpan">(str, littleEndian)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fromBinary = function (str, littleEndian) {
    return ByteBuffer.wrap(new Buffer(str, "binary"), littleEndian);
    return bb;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.fromDebug" id="apidoc.element.bytebuffer.fromDebug">
        function <span class="apidocSignatureSpan">bytebuffer.</span>fromDebug
        <span class="apidocSignatureSpan">(str, littleEndian, noAssert)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fromDebug = function (str, littleEndian, noAssert) {
    var k = str.length,
        bb = new ByteBuffer(((k+1)/3)|0, littleEndian, noAssert);
    var i = 0, j = 0, ch, b,
        rs = false, // Require symbol next
        ho = false, hm = false, hl = false, // Already has offset (ho), markedOffset (hm), limit (hl)?
        fail = false;
    while (i&lt;k) {
        switch (ch = str.charAt(i++)) {
            case '!':
                if (!noAssert) {
                    if (ho || hm || hl) {
                        fail = true;
                        break;
                    }
                    ho = hm = hl = true;
                }
                bb.offset = bb.markedOffset = bb.limit = j;
                rs = false;
                break;
            case '|':
                if (!noAssert) {
                    if (ho || hl) {
                        fail = true;
                        break;
                    }
                    ho = hl = true;
                }
                bb.offset = bb.limit = j;
                rs = false;
                break;
            case '[':
                if (!noAssert) {
                    if (ho || hm) {
                        fail = true;
                        break;
                    }
                    ho = hm = true;
                }
                bb.offset = bb.markedOffset = j;
                rs = false;
                break;
            case '&lt;':
                if (!noAssert) {
                    if (ho) {
                        fail = true;
                        break;
                    }
                    ho = true;
                }
                bb.offset = j;
                rs = false;
                break;
            case ']':
                if (!noAssert) {
                    if (hl || hm) {
                        fail = true;
                        break;
                    }
                    hl = hm = true;
                }
                bb.limit = bb.markedOffset = j;
                rs = false;
                break;
            case '&gt;':
                if (!noAssert) {
                    if (hl) {
                        fail = true;
                        break;
                    }
                    hl = true;
                }
                bb.limit = j;
                rs = false;
                break;
            case "'":
                if (!noAssert) {
                    if (hm) {
                        fail = true;
                        break;
                    }
                    hm = true;
                }
                bb.markedOffset = j;
                rs = false;
                break;
            case ' ':
                rs = false;
                break;
            default:
                if (!noAssert) {
                    if (rs) {
                        fail = true;
                        break;
                    }
                }
                b = parseInt(ch+str.charAt(i++), 16);
                if (!noAssert) {
                    if (isNaN(b) || b &lt; 0 || b &gt; 255)
                        throw TypeError("Illegal str: Not a debug encoded string");
                }
                bb.buffer[j++] = b;
                rs = true;
        }
        if (fail)
            throw TypeError("Illegal str: Invalid symbol at "+i);
    }
    if (!noAssert) {
        if (!ho || !hl)
            throw TypeError("Illegal str: Missing offset or limit");
        if (j&lt;bb.buffer.length)
            throw TypeError("Illegal str: Not a debug encoded string (is it hex?) "+j+" &lt; "+k);
    }
    return bb;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.fromHex" id="apidoc.element.bytebuffer.fromHex">
        function <span class="apidocSignatureSpan">bytebuffer.</span>fromHex
        <span class="apidocSignatureSpan">(str, littleEndian, noAssert)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fromHex = function (str, littleEndian, noAssert) {
    if (!noAssert) {
        if (typeof str !== 'string')
            throw TypeError("Illegal str: Not a string");
        if (str.length % 2 !== 0)
            throw TypeError("Illegal str: Length not a multiple of 2");
    }
    var bb = new ByteBuffer(0, littleEndian, true);
    bb.buffer = new Buffer(str, "hex");
    bb.limit = bb.buffer.length;
    return bb;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.fromUTF8" id="apidoc.element.bytebuffer.fromUTF8">
        function <span class="apidocSignatureSpan">bytebuffer.</span>fromUTF8
        <span class="apidocSignatureSpan">(str, littleEndian, noAssert)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fromUTF8 = function (str, littleEndian, noAssert) {
    if (!noAssert)
        if (typeof str !== 'string')
            throw TypeError("Illegal str: Not a string");
    var bb = new ByteBuffer(0, littleEndian, noAssert);
    bb.buffer = new Buffer(str, "utf8");
    bb.limit = bb.buffer.length;
    return bb;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.index" id="apidoc.element.bytebuffer.index">
        function <span class="apidocSignatureSpan">bytebuffer.</span>index
        <span class="apidocSignatureSpan">(capacity, littleEndian, noAssert)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">index = function (capacity, littleEndian, noAssert) {
    if (typeof capacity === 'undefined')
        capacity = ByteBuffer.DEFAULT_CAPACITY;
    if (typeof littleEndian === 'undefined')
        littleEndian = ByteBuffer.DEFAULT_ENDIAN;
    if (typeof noAssert === 'undefined')
        noAssert = ByteBuffer.DEFAULT_NOASSERT;
    if (!noAssert) {
        capacity = capacity | 0;
        if (capacity &lt; 0)
            throw RangeError("Illegal capacity");
        littleEndian = !!littleEndian;
        noAssert = !!noAssert;
    }

    /**
     * Backing node Buffer.
     * @type {!Buffer}
     * @expose
     */
    this.buffer = capacity === 0 ? EMPTY_BUFFER : new Buffer(capacity);

    /**
     * Absolute read/write offset.
     * @type {number}
     * @expose
     * @see ByteBuffer#flip
     * @see ByteBuffer#clear
     */
    this.offset = 0;

    /**
     * Marked offset.
     * @type {number}
     * @expose
     * @see ByteBuffer#mark
     * @see ByteBuffer#reset
     */
    this.markedOffset = -1;

    /**
     * Absolute limit of the contained data. Set to the backing buffer's capacity upon allocation.
     * @type {number}
     * @expose
     * @see ByteBuffer#flip
     * @see ByteBuffer#clear
     */
    this.limit = capacity;

    /**
     * Whether to use little endian byte order, defaults to `false` for big endian.
     * @type {boolean}
     * @expose
     */
    this.littleEndian = littleEndian;

    /**
     * Whether to skip assertions of offsets and values, defaults to `false`.
     * @type {boolean}
     * @expose
     */
    this.noAssert = noAssert;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.isByteBuffer" id="apidoc.element.bytebuffer.isByteBuffer">
        function <span class="apidocSignatureSpan">bytebuffer.</span>isByteBuffer
        <span class="apidocSignatureSpan">(bb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isByteBuffer = function (bb) {
    return (bb &amp;&amp; bb["__isByteBuffer__"]) === true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.type" id="apidoc.element.bytebuffer.type">
        function <span class="apidocSignatureSpan">bytebuffer.</span>type
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">type = function () {
    return Buffer;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.wrap" id="apidoc.element.bytebuffer.wrap">
        function <span class="apidocSignatureSpan">bytebuffer.</span>wrap
        <span class="apidocSignatureSpan">(buffer, encoding, littleEndian, noAssert)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">wrap = function (buffer, encoding, littleEndian, noAssert) {
    if (typeof encoding !== 'string') {
        noAssert = littleEndian;
        littleEndian = encoding;
        encoding = undefined;
    }
    if (typeof buffer === 'string') {
        if (typeof encoding === 'undefined')
            encoding = "utf8";
        switch (encoding) {
            case "base64":
                return ByteBuffer.fromBase64(buffer, littleEndian);
            case "hex":
                return ByteBuffer.fromHex(buffer, littleEndian);
            case "binary":
                return ByteBuffer.fromBinary(buffer, littleEndian);
            case "utf8":
                return ByteBuffer.fromUTF8(buffer, littleEndian);
            case "debug":
                return ByteBuffer.fromDebug(buffer, littleEndian);
            default:
                throw Error("Unsupported encoding: "+encoding);
        }
    }
    if (buffer === null || typeof buffer !== 'object')
        throw TypeError("Illegal buffer");
    var bb;
    if (ByteBuffer.isByteBuffer(buffer)) {
        bb = ByteBufferPrototype.clone.call(buffer);
        bb.markedOffset = -1;
        return bb;
    }
    var i = 0,
        k = 0,
        b;
    if (buffer instanceof Uint8Array) { // Extract bytes from Uint8Array
        b = new Buffer(buffer.length);
        if (memcpy) { // Fast
            memcpy(b, 0, buffer.buffer, buffer.byteOffset, buffer.byteOffset + buffer.length);
        } else { // Slow
            for (i=0, k=buffer.length; i&lt;k; ++i)
                b[i] = buffer[i];
        }
        buffer = b;
    } else if (buffer instanceof ArrayBuffer) { // Convert ArrayBuffer to Buffer
        b = new Buffer(buffer.byteLength);
        if (memcpy) { // Fast
            memcpy(b, 0, buffer, 0, buffer.byteLength);
        } else { // Slow
            buffer = new Uint8Array(buffer);
            for (i=0, k=buffer.length; i&lt;k; ++i) {
                b[i] = buffer[i];
            }
        }
        buffer = b;
    } else if (!(buffer instanceof Buffer)) { // Create from octets if it is an error, otherwise fail
        if (Object.prototype.toString.call(buffer) !== "[object Array]")
            throw TypeError("Illegal buffer");
        buffer = new Buffer(buffer);
    }
    bb = new ByteBuffer(0, littleEndian, noAssert);
    if (buffer.length &gt; 0) { // Avoid references to more than one EMPTY_BUFFER
        bb.buffer = buffer;
        bb.limit = buffer.length;
    }
    return bb;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.zigZagDecode32" id="apidoc.element.bytebuffer.zigZagDecode32">
        function <span class="apidocSignatureSpan">bytebuffer.</span>zigZagDecode32
        <span class="apidocSignatureSpan">(n)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">zigZagDecode32 = function (n) {
    return ((n &gt;&gt;&gt; 1) ^ -(n &amp; 1)) | 0; // // ref: src/google/protobuf/wire_format_lite.h
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.zigZagDecode64" id="apidoc.element.bytebuffer.zigZagDecode64">
        function <span class="apidocSignatureSpan">bytebuffer.</span>zigZagDecode64
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">zigZagDecode64 = function (value) {
    if (typeof value === 'number')
        value = Long.fromNumber(value, false);
    else if (typeof value === 'string')
        value = Long.fromString(value, false);
    else if (value.unsigned !== false) value = value.toSigned();
    // ref: src/google/protobuf/wire_format_lite.h
    return value.shiftRightUnsigned(1).xor(value.and(Long.ONE).toSigned().negate()).toSigned();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.zigZagEncode32" id="apidoc.element.bytebuffer.zigZagEncode32">
        function <span class="apidocSignatureSpan">bytebuffer.</span>zigZagEncode32
        <span class="apidocSignatureSpan">(n)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">zigZagEncode32 = function (n) {
    return (((n |= 0) &lt;&lt; 1) ^ (n &gt;&gt; 31)) &gt;&gt;&gt; 0; // ref: src/google/protobuf/wire_format_lite.h
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.zigZagEncode64" id="apidoc.element.bytebuffer.zigZagEncode64">
        function <span class="apidocSignatureSpan">bytebuffer.</span>zigZagEncode64
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">zigZagEncode64 = function (value) {
    if (typeof value === 'number')
        value = Long.fromNumber(value, false);
    else if (typeof value === 'string')
        value = Long.fromString(value, false);
    else if (value.unsigned !== false) value = value.toSigned();
    // ref: src/google/protobuf/wire_format_lite.h
    return value.shiftLeft(1).xor(value.shiftRight(63)).toUnsigned();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




















</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.bytebuffer.Long" id="apidoc.module.bytebuffer.Long">module bytebuffer.Long</a></h1>


    <h2>
        <a href="#apidoc.element.bytebuffer.Long.Long" id="apidoc.element.bytebuffer.Long.Long">
        function <span class="apidocSignatureSpan">bytebuffer.</span>Long
        <span class="apidocSignatureSpan">(low, high, unsigned)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Long(low, high, unsigned) {

    /**
     * The low 32 bits as a signed value.
     * @type {number}
     */
    this.low = low | 0;

    /**
     * The high 32 bits as a signed value.
     * @type {number}
     */
    this.high = high | 0;

    /**
     * Whether unsigned or not.
     * @type {boolean}
     */
    this.unsigned = !!unsigned;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.Long.fromBits" id="apidoc.element.bytebuffer.Long.fromBits">
        function <span class="apidocSignatureSpan">bytebuffer.Long.</span>fromBits
        <span class="apidocSignatureSpan">(lowBits, highBits, unsigned)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function fromBits(lowBits, highBits, unsigned) {
    return new Long(lowBits, highBits, unsigned);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.Long.fromInt" id="apidoc.element.bytebuffer.Long.fromInt">
        function <span class="apidocSignatureSpan">bytebuffer.Long.</span>fromInt
        <span class="apidocSignatureSpan">(value, unsigned)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function fromInt(value, unsigned) {
    var obj, cachedObj, cache;
    if (unsigned) {
        value &gt;&gt;&gt;= 0;
        if (cache = (0 &lt;= value &amp;&amp; value &lt; 256)) {
            cachedObj = UINT_CACHE[value];
            if (cachedObj)
                return cachedObj;
        }
        obj = fromBits(value, (value | 0) &lt; 0 ? -1 : 0, true);
        if (cache)
            UINT_CACHE[value] = obj;
        return obj;
    } else {
        value |= 0;
        if (cache = (-128 &lt;= value &amp;&amp; value &lt; 128)) {
            cachedObj = INT_CACHE[value];
            if (cachedObj)
                return cachedObj;
        }
        obj = fromBits(value, value &lt; 0 ? -1 : 0, false);
        if (cache)
            INT_CACHE[value] = obj;
        return obj;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.Long.fromNumber" id="apidoc.element.bytebuffer.Long.fromNumber">
        function <span class="apidocSignatureSpan">bytebuffer.Long.</span>fromNumber
        <span class="apidocSignatureSpan">(value, unsigned)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function fromNumber(value, unsigned) {
    if (isNaN(value) || !isFinite(value))
        return unsigned ? UZERO : ZERO;
    if (unsigned) {
        if (value &lt; 0)
            return UZERO;
        if (value &gt;= TWO_PWR_64_DBL)
            return MAX_UNSIGNED_VALUE;
    } else {
        if (value &lt;= -TWO_PWR_63_DBL)
            return MIN_VALUE;
        if (value + 1 &gt;= TWO_PWR_63_DBL)
            return MAX_VALUE;
    }
    if (value &lt; 0)
        return fromNumber(-value, unsigned).neg();
    return fromBits((value % TWO_PWR_32_DBL) | 0, (value / TWO_PWR_32_DBL) | 0, unsigned);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {boolean=} unsigned Whether explicitly unsigned
 * @returns {number|!Long} Type-safe value
 * @throws {TypeError} If `value` is not an integer or Long
 * @inner
 */
function assertLong(value, unsigned) {
if (typeof value === 'number') {
    return Long.<span class="apidocCodeKeywordSpan">fromNumber</span>(value, unsigned);
} else if (typeof value === 'string') {
    return Long.fromString(value, unsigned);
} else if (value &amp;&amp; value instanceof Long) {
    if (typeof unsigned !== 'undefined') {
        if (unsigned &amp;&amp; !value.unsigned) return value.toUnsigned();
        if (!unsigned &amp;&amp; value.unsigned) return value.toSigned();
    }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.Long.fromString" id="apidoc.element.bytebuffer.Long.fromString">
        function <span class="apidocSignatureSpan">bytebuffer.Long.</span>fromString
        <span class="apidocSignatureSpan">(str, unsigned, radix)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function fromString(str, unsigned, radix) {
    if (str.length === 0)
        throw Error('empty string');
    if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity")
        return ZERO;
    if (typeof unsigned === 'number') {
        // For goog.math.long compatibility
        radix = unsigned,
        unsigned = false;
    } else {
        unsigned = !! unsigned;
    }
    radix = radix || 10;
    if (radix &lt; 2 || 36 &lt; radix)
        throw RangeError('radix');

    var p;
    if ((p = str.indexOf('-')) &gt; 0)
        throw Error('interior hyphen');
    else if (p === 0) {
        return fromString(str.substring(1), unsigned, radix).neg();
    }

    // Do several (8) digits each time through the loop, so as to
    // minimize the calls to the very expensive emulated div.
    var radixToPower = fromNumber(pow_dbl(radix, 8));

    var result = ZERO;
    for (var i = 0; i &lt; str.length; i += 8) {
        var size = Math.min(8, str.length - i),
            value = parseInt(str.substring(i, i + size), radix);
        if (size &lt; 8) {
            var power = fromNumber(pow_dbl(radix, size));
            result = result.mul(power).add(fromNumber(value));
        } else {
            result = result.mul(radixToPower);
            result = result.add(fromNumber(value));
        }
    }
    result.unsigned = unsigned;
    return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @throws {TypeError} If `value` is not an integer or Long
 * @inner
 */
function assertLong(value, unsigned) {
if (typeof value === 'number') {
    return Long.fromNumber(value, unsigned);
} else if (typeof value === 'string') {
    return Long.<span class="apidocCodeKeywordSpan">fromString</span>(value, unsigned);
} else if (value &amp;&amp; value instanceof Long) {
    if (typeof unsigned !== 'undefined') {
        if (unsigned &amp;&amp; !value.unsigned) return value.toUnsigned();
        if (!unsigned &amp;&amp; value.unsigned) return value.toSigned();
    }
    return value;
} else
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.Long.fromValue" id="apidoc.element.bytebuffer.Long.fromValue">
        function <span class="apidocSignatureSpan">bytebuffer.Long.</span>fromValue
        <span class="apidocSignatureSpan">(val)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function fromValue(val) {
    if (val /* is compatible */ instanceof Long)
        return val;
    if (typeof val === 'number')
        return fromNumber(val);
    if (typeof val === 'string')
        return fromString(val);
    // Throws for non-objects, converts non-instanceof Long:
    return fromBits(val.low, val.high, val.unsigned);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.Long.isLong" id="apidoc.element.bytebuffer.Long.isLong">
        function <span class="apidocSignatureSpan">bytebuffer.Long.</span>isLong
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isLong(obj) {
    return (obj &amp;&amp; obj["__isLong__"]) === true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


















</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.bytebuffer.Long.prototype" id="apidoc.module.bytebuffer.Long.prototype">module bytebuffer.Long.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.bytebuffer.Long.prototype.add" id="apidoc.element.bytebuffer.Long.prototype.add">
        function <span class="apidocSignatureSpan">bytebuffer.Long.prototype.</span>add
        <span class="apidocSignatureSpan">(addend)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function add(addend) {
    if (!isLong(addend))
        addend = fromValue(addend);

    // Divide each number into 4 chunks of 16 bits, and then sum the chunks.

    var a48 = this.high &gt;&gt;&gt; 16;
    var a32 = this.high &amp; 0xFFFF;
    var a16 = this.low &gt;&gt;&gt; 16;
    var a00 = this.low &amp; 0xFFFF;

    var b48 = addend.high &gt;&gt;&gt; 16;
    var b32 = addend.high &amp; 0xFFFF;
    var b16 = addend.low &gt;&gt;&gt; 16;
    var b00 = addend.low &amp; 0xFFFF;

    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
    c00 += a00 + b00;
    c16 += c00 &gt;&gt;&gt; 16;
    c00 &amp;= 0xFFFF;
    c16 += a16 + b16;
    c32 += c16 &gt;&gt;&gt; 16;
    c16 &amp;= 0xFFFF;
    c32 += a32 + b32;
    c48 += c32 &gt;&gt;&gt; 16;
    c32 &amp;= 0xFFFF;
    c48 += a48 + b48;
    c48 &amp;= 0xFFFF;
    return fromBits((c16 &lt;&lt; 16) | c00, (c48 &lt;&lt; 16) | c32, this.unsigned);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.Long.prototype.and" id="apidoc.element.bytebuffer.Long.prototype.and">
        function <span class="apidocSignatureSpan">bytebuffer.Long.prototype.</span>and
        <span class="apidocSignatureSpan">(other)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function and(other) {
    if (!isLong(other))
        other = fromValue(other);
    return fromBits(this.low &amp; other.low, this.high &amp; other.high, this.unsigned);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.Long.prototype.comp" id="apidoc.element.bytebuffer.Long.prototype.comp">
        function <span class="apidocSignatureSpan">bytebuffer.Long.prototype.</span>comp
        <span class="apidocSignatureSpan">(other)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function compare(other) {
    if (!isLong(other))
        other = fromValue(other);
    if (this.eq(other))
        return 0;
    var thisNeg = this.isNegative(),
        otherNeg = other.isNegative();
    if (thisNeg &amp;&amp; !otherNeg)
        return -1;
    if (!thisNeg &amp;&amp; otherNeg)
        return 1;
    // At this point the sign bits are the same
    if (!this.unsigned)
        return this.sub(other).isNegative() ? -1 : 1;
    // Both are positive if at least one is unsigned
    return (other.high &gt;&gt;&gt; 0) &gt; (this.high &gt;&gt;&gt; 0) || (other.high === this.high &amp;&amp; (other.low &gt;&gt;&gt; 0) &gt; (this.low &gt;&gt;&gt; 0)) ? -1 : 1
;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.Long.prototype.compare" id="apidoc.element.bytebuffer.Long.prototype.compare">
        function <span class="apidocSignatureSpan">bytebuffer.Long.prototype.</span>compare
        <span class="apidocSignatureSpan">(other)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function compare(other) {
    if (!isLong(other))
        other = fromValue(other);
    if (this.eq(other))
        return 0;
    var thisNeg = this.isNegative(),
        otherNeg = other.isNegative();
    if (thisNeg &amp;&amp; !otherNeg)
        return -1;
    if (!thisNeg &amp;&amp; otherNeg)
        return 1;
    // At this point the sign bits are the same
    if (!this.unsigned)
        return this.sub(other).isNegative() ? -1 : 1;
    // Both are positive if at least one is unsigned
    return (other.high &gt;&gt;&gt; 0) &gt; (this.high &gt;&gt;&gt; 0) || (other.high === this.high &amp;&amp; (other.low &gt;&gt;&gt; 0) &gt; (this.low &gt;&gt;&gt; 0)) ? -1 : 1
;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.Long.prototype.div" id="apidoc.element.bytebuffer.Long.prototype.div">
        function <span class="apidocSignatureSpan">bytebuffer.Long.prototype.</span>div
        <span class="apidocSignatureSpan">(divisor)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function divide(divisor) {
    if (!isLong(divisor))
        divisor = fromValue(divisor);
    if (divisor.isZero())
        throw Error('division by zero');
    if (this.isZero())
        return this.unsigned ? UZERO : ZERO;
    var approx, rem, res;
    if (!this.unsigned) {
        // This section is only relevant for signed longs and is derived from the
        // closure library as a whole.
        if (this.eq(MIN_VALUE)) {
            if (divisor.eq(ONE) || divisor.eq(NEG_ONE))
                return MIN_VALUE;  // recall that -MIN_VALUE == MIN_VALUE
            else if (divisor.eq(MIN_VALUE))
                return ONE;
            else {
                // At this point, we have |other| &gt;= 2, so |this/other| &lt; |MIN_VALUE|.
                var halfThis = this.shr(1);
                approx = halfThis.div(divisor).shl(1);
                if (approx.eq(ZERO)) {
                    return divisor.isNegative() ? ONE : NEG_ONE;
                } else {
                    rem = this.sub(divisor.mul(approx));
                    res = approx.add(rem.div(divisor));
                    return res;
                }
            }
        } else if (divisor.eq(MIN_VALUE))
            return this.unsigned ? UZERO : ZERO;
        if (this.isNegative()) {
            if (divisor.isNegative())
                return this.neg().div(divisor.neg());
            return this.neg().div(divisor).neg();
        } else if (divisor.isNegative())
            return this.div(divisor.neg()).neg();
        res = ZERO;
    } else {
        // The algorithm below has not been made for unsigned longs. It's therefore
        // required to take special care of the MSB prior to running it.
        if (!divisor.unsigned)
            divisor = divisor.toUnsigned();
        if (divisor.gt(this))
            return UZERO;
        if (divisor.gt(this.shru(1))) // 15 &gt;&gt;&gt; 1 = 7 ; with divisor = 8 ; true
            return UONE;
        res = UZERO;
    }

    // Repeat the following until the remainder is less than other:  find a
    // floating-point that approximates remainder / other *from below*, add this
    // into the result, and subtract it from the remainder.  It is critical that
    // the approximate value is less than or equal to the real value so that the
    // remainder never becomes negative.
    rem = this;
    while (rem.gte(divisor)) {
        // Approximate the result of division. This may be a little greater or
        // smaller than the actual value.
        approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));

        // We will tweak the approximate result by changing it in the 48-th digit or
        // the smallest non-fractional digit, whichever is larger.
        var log2 = Math.ceil(Math.log(approx) / Math.LN2),
            delta = (log2 &lt;= 48) ? 1 : pow_dbl(2, log2 - 48),

        // Decrease the approximation until it is smaller than the remainder.  Note
        // that if it is too large, the product overflows and is negative.
            approxRes = fromNumber(approx),
            approxRem = approxRes.mul(divisor);
        while (approxRem.isNegative() || approxRem.gt(rem)) {
            approx -= delta;
            approxRes = fromNumber(approx, this.unsigned);
            approxRem = approxRes.mul(divisor);
        }

        // We know the answer can't be zero... and actually, zero would cause
        // infinite recursion since we would make no progress.
        if (approxRes.isZero())
            approxRes = ONE;

        res = res.add(approxRes);
        rem = rem.sub(approxRem);
    }
    return res;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.Long.prototype.divide" id="apidoc.element.bytebuffer.Long.prototype.divide">
        function <span class="apidocSignatureSpan">bytebuffer.Long.prototype.</span>divide
        <span class="apidocSignatureSpan">(divisor)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function divide(divisor) {
    if (!isLong(divisor))
        divisor = fromValue(divisor);
    if (divisor.isZero())
        throw Error('division by zero');
    if (this.isZero())
        return this.unsigned ? UZERO : ZERO;
    var approx, rem, res;
    if (!this.unsigned) {
        // This section is only relevant for signed longs and is derived from the
        // closure library as a whole.
        if (this.eq(MIN_VALUE)) {
            if (divisor.eq(ONE) || divisor.eq(NEG_ONE))
                return MIN_VALUE;  // recall that -MIN_VALUE == MIN_VALUE
            else if (divisor.eq(MIN_VALUE))
                return ONE;
            else {
                // At this point, we have |other| &gt;= 2, so |this/other| &lt; |MIN_VALUE|.
                var halfThis = this.shr(1);
                approx = halfThis.div(divisor).shl(1);
                if (approx.eq(ZERO)) {
                    return divisor.isNegative() ? ONE : NEG_ONE;
                } else {
                    rem = this.sub(divisor.mul(approx));
                    res = approx.add(rem.div(divisor));
                    return res;
                }
            }
        } else if (divisor.eq(MIN_VALUE))
            return this.unsigned ? UZERO : ZERO;
        if (this.isNegative()) {
            if (divisor.isNegative())
                return this.neg().div(divisor.neg());
            return this.neg().div(divisor).neg();
        } else if (divisor.isNegative())
            return this.div(divisor.neg()).neg();
        res = ZERO;
    } else {
        // The algorithm below has not been made for unsigned longs. It's therefore
        // required to take special care of the MSB prior to running it.
        if (!divisor.unsigned)
            divisor = divisor.toUnsigned();
        if (divisor.gt(this))
            return UZERO;
        if (divisor.gt(this.shru(1))) // 15 &gt;&gt;&gt; 1 = 7 ; with divisor = 8 ; true
            return UONE;
        res = UZERO;
    }

    // Repeat the following until the remainder is less than other:  find a
    // floating-point that approximates remainder / other *from below*, add this
    // into the result, and subtract it from the remainder.  It is critical that
    // the approximate value is less than or equal to the real value so that the
    // remainder never becomes negative.
    rem = this;
    while (rem.gte(divisor)) {
        // Approximate the result of division. This may be a little greater or
        // smaller than the actual value.
        approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));

        // We will tweak the approximate result by changing it in the 48-th digit or
        // the smallest non-fractional digit, whichever is larger.
        var log2 = Math.ceil(Math.log(approx) / Math.LN2),
            delta = (log2 &lt;= 48) ? 1 : pow_dbl(2, log2 - 48),

        // Decrease the approximation until it is smaller than the remainder.  Note
        // that if it is too large, the product overflows and is negative.
            approxRes = fromNumber(approx),
            approxRem = approxRes.mul(divisor);
        while (approxRem.isNegative() || approxRem.gt(rem)) {
            approx -= delta;
            approxRes = fromNumber(approx, this.unsigned);
            approxRem = approxRes.mul(divisor);
        }

        // We know the answer can't be zero... and actually, zero would cause
        // infinite recursion since we would make no progress.
        if (approxRes.isZero())
            approxRes = ONE;

        res = res.add(approxRes);
        rem = rem.sub(approxRem);
    }
    return res;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.Long.prototype.eq" id="apidoc.element.bytebuffer.Long.prototype.eq">
        function <span class="apidocSignatureSpan">bytebuffer.Long.prototype.</span>eq
        <span class="apidocSignatureSpan">(other)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function equals(other) {
    if (!isLong(other))
        other = fromValue(other);
    if (this.unsigned !== other.unsigned &amp;&amp; (this.high &gt;&gt;&gt; 31) === 1 &amp;&amp; (other.high &gt;&gt;&gt; 31) === 1)
        return false;
    return this.high === other.high &amp;&amp; this.low === other.low;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.Long.prototype.equals" id="apidoc.element.bytebuffer.Long.prototype.equals">
        function <span class="apidocSignatureSpan">bytebuffer.Long.prototype.</span>equals
        <span class="apidocSignatureSpan">(other)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function equals(other) {
    if (!isLong(other))
        other = fromValue(other);
    if (this.unsigned !== other.unsigned &amp;&amp; (this.high &gt;&gt;&gt; 31) === 1 &amp;&amp; (other.high &gt;&gt;&gt; 31) === 1)
        return false;
    return this.high === other.high &amp;&amp; this.low === other.low;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.Long.prototype.getHighBits" id="apidoc.element.bytebuffer.Long.prototype.getHighBits">
        function <span class="apidocSignatureSpan">bytebuffer.Long.prototype.</span>getHighBits
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getHighBits() {
    return this.high;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.Long.prototype.getHighBitsUnsigned" id="apidoc.element.bytebuffer.Long.prototype.getHighBitsUnsigned">
        function <span class="apidocSignatureSpan">bytebuffer.Long.prototype.</span>getHighBitsUnsigned
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getHighBitsUnsigned() {
    return this.high &gt;&gt;&gt; 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.Long.prototype.getLowBits" id="apidoc.element.bytebuffer.Long.prototype.getLowBits">
        function <span class="apidocSignatureSpan">bytebuffer.Long.prototype.</span>getLowBits
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getLowBits() {
    return this.low;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.Long.prototype.getLowBitsUnsigned" id="apidoc.element.bytebuffer.Long.prototype.getLowBitsUnsigned">
        function <span class="apidocSignatureSpan">bytebuffer.Long.prototype.</span>getLowBitsUnsigned
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getLowBitsUnsigned() {
    return this.low &gt;&gt;&gt; 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.Long.prototype.getNumBitsAbs" id="apidoc.element.bytebuffer.Long.prototype.getNumBitsAbs">
        function <span class="apidocSignatureSpan">bytebuffer.Long.prototype.</span>getNumBitsAbs
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getNumBitsAbs() {
    if (this.isNegative()) // Unsigned Longs are never negative
        return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
    var val = this.high != 0 ? this.high : this.low;
    for (var bit = 31; bit &gt; 0; bit--)
        if ((val &amp; (1 &lt;&lt; bit)) != 0)
            break;
    return this.high != 0 ? bit + 33 : bit + 1;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.Long.prototype.greaterThan" id="apidoc.element.bytebuffer.Long.prototype.greaterThan">
        function <span class="apidocSignatureSpan">bytebuffer.Long.prototype.</span>greaterThan
        <span class="apidocSignatureSpan">(other)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function greaterThan(other) {
    return this.comp(/* validates */ other) &gt; 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.Long.prototype.greaterThanOrEqual" id="apidoc.element.bytebuffer.Long.prototype.greaterThanOrEqual">
        function <span class="apidocSignatureSpan">bytebuffer.Long.prototype.</span>greaterThanOrEqual
        <span class="apidocSignatureSpan">(other)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function greaterThanOrEqual(other) {
    return this.comp(/* validates */ other) &gt;= 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.Long.prototype.gt" id="apidoc.element.bytebuffer.Long.prototype.gt">
        function <span class="apidocSignatureSpan">bytebuffer.Long.prototype.</span>gt
        <span class="apidocSignatureSpan">(other)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function greaterThan(other) {
    return this.comp(/* validates */ other) &gt; 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.Long.prototype.gte" id="apidoc.element.bytebuffer.Long.prototype.gte">
        function <span class="apidocSignatureSpan">bytebuffer.Long.prototype.</span>gte
        <span class="apidocSignatureSpan">(other)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function greaterThanOrEqual(other) {
    return this.comp(/* validates */ other) &gt;= 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.Long.prototype.isEven" id="apidoc.element.bytebuffer.Long.prototype.isEven">
        function <span class="apidocSignatureSpan">bytebuffer.Long.prototype.</span>isEven
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isEven() {
    return (this.low &amp; 1) === 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.Long.prototype.isNegative" id="apidoc.element.bytebuffer.Long.prototype.isNegative">
        function <span class="apidocSignatureSpan">bytebuffer.Long.prototype.</span>isNegative
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isNegative() {
    return !this.unsigned &amp;&amp; this.high &lt; 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.Long.prototype.isOdd" id="apidoc.element.bytebuffer.Long.prototype.isOdd">
        function <span class="apidocSignatureSpan">bytebuffer.Long.prototype.</span>isOdd
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isOdd() {
    return (this.low &amp; 1) === 1;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.Long.prototype.isPositive" id="apidoc.element.bytebuffer.Long.prototype.isPositive">
        function <span class="apidocSignatureSpan">bytebuffer.Long.prototype.</span>isPositive
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isPositive() {
    return this.unsigned || this.high &gt;= 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.Long.prototype.isZero" id="apidoc.element.bytebuffer.Long.prototype.isZero">
        function <span class="apidocSignatureSpan">bytebuffer.Long.prototype.</span>isZero
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isZero() {
    return this.high === 0 &amp;&amp; this.low === 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.Long.prototype.lessThan" id="apidoc.element.bytebuffer.Long.prototype.lessThan">
        function <span class="apidocSignatureSpan">bytebuffer.Long.prototype.</span>lessThan
        <span class="apidocSignatureSpan">(other)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function lessThan(other) {
    return this.comp(/* validates */ other) &lt; 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.Long.prototype.lessThanOrEqual" id="apidoc.element.bytebuffer.Long.prototype.lessThanOrEqual">
        function <span class="apidocSignatureSpan">bytebuffer.Long.prototype.</span>lessThanOrEqual
        <span class="apidocSignatureSpan">(other)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function lessThanOrEqual(other) {
    return this.comp(/* validates */ other) &lt;= 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.Long.prototype.lt" id="apidoc.element.bytebuffer.Long.prototype.lt">
        function <span class="apidocSignatureSpan">bytebuffer.Long.prototype.</span>lt
        <span class="apidocSignatureSpan">(other)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function lessThan(other) {
    return this.comp(/* validates */ other) &lt; 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.Long.prototype.lte" id="apidoc.element.bytebuffer.Long.prototype.lte">
        function <span class="apidocSignatureSpan">bytebuffer.Long.prototype.</span>lte
        <span class="apidocSignatureSpan">(other)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function lessThanOrEqual(other) {
    return this.comp(/* validates */ other) &lt;= 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.Long.prototype.mod" id="apidoc.element.bytebuffer.Long.prototype.mod">
        function <span class="apidocSignatureSpan">bytebuffer.Long.prototype.</span>mod
        <span class="apidocSignatureSpan">(divisor)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function modulo(divisor) {
    if (!isLong(divisor))
        divisor = fromValue(divisor);
    return this.sub(this.div(divisor).mul(divisor));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.Long.prototype.modulo" id="apidoc.element.bytebuffer.Long.prototype.modulo">
        function <span class="apidocSignatureSpan">bytebuffer.Long.prototype.</span>modulo
        <span class="apidocSignatureSpan">(divisor)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function modulo(divisor) {
    if (!isLong(divisor))
        divisor = fromValue(divisor);
    return this.sub(this.div(divisor).mul(divisor));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.Long.prototype.mul" id="apidoc.element.bytebuffer.Long.prototype.mul">
        function <span class="apidocSignatureSpan">bytebuffer.Long.prototype.</span>mul
        <span class="apidocSignatureSpan">(multiplier)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function multiply(multiplier) {
    if (this.isZero())
        return ZERO;
    if (!isLong(multiplier))
        multiplier = fromValue(multiplier);
    if (multiplier.isZero())
        return ZERO;
    if (this.eq(MIN_VALUE))
        return multiplier.isOdd() ? MIN_VALUE : ZERO;
    if (multiplier.eq(MIN_VALUE))
        return this.isOdd() ? MIN_VALUE : ZERO;

    if (this.isNegative()) {
        if (multiplier.isNegative())
            return this.neg().mul(multiplier.neg());
        else
            return this.neg().mul(multiplier).neg();
    } else if (multiplier.isNegative())
        return this.mul(multiplier.neg()).neg();

    // If both longs are small, use float multiplication
    if (this.lt(TWO_PWR_24) &amp;&amp; multiplier.lt(TWO_PWR_24))
        return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);

    // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.
    // We can skip products that would overflow.

    var a48 = this.high &gt;&gt;&gt; 16;
    var a32 = this.high &amp; 0xFFFF;
    var a16 = this.low &gt;&gt;&gt; 16;
    var a00 = this.low &amp; 0xFFFF;

    var b48 = multiplier.high &gt;&gt;&gt; 16;
    var b32 = multiplier.high &amp; 0xFFFF;
    var b16 = multiplier.low &gt;&gt;&gt; 16;
    var b00 = multiplier.low &amp; 0xFFFF;

    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
    c00 += a00 * b00;
    c16 += c00 &gt;&gt;&gt; 16;
    c00 &amp;= 0xFFFF;
    c16 += a16 * b00;
    c32 += c16 &gt;&gt;&gt; 16;
    c16 &amp;= 0xFFFF;
    c16 += a00 * b16;
    c32 += c16 &gt;&gt;&gt; 16;
    c16 &amp;= 0xFFFF;
    c32 += a32 * b00;
    c48 += c32 &gt;&gt;&gt; 16;
    c32 &amp;= 0xFFFF;
    c32 += a16 * b16;
    c48 += c32 &gt;&gt;&gt; 16;
    c32 &amp;= 0xFFFF;
    c32 += a00 * b32;
    c48 += c32 &gt;&gt;&gt; 16;
    c32 &amp;= 0xFFFF;
    c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
    c48 &amp;= 0xFFFF;
    return fromBits((c16 &lt;&lt; 16) | c00, (c48 &lt;&lt; 16) | c32, this.unsigned);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.Long.prototype.multiply" id="apidoc.element.bytebuffer.Long.prototype.multiply">
        function <span class="apidocSignatureSpan">bytebuffer.Long.prototype.</span>multiply
        <span class="apidocSignatureSpan">(multiplier)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function multiply(multiplier) {
    if (this.isZero())
        return ZERO;
    if (!isLong(multiplier))
        multiplier = fromValue(multiplier);
    if (multiplier.isZero())
        return ZERO;
    if (this.eq(MIN_VALUE))
        return multiplier.isOdd() ? MIN_VALUE : ZERO;
    if (multiplier.eq(MIN_VALUE))
        return this.isOdd() ? MIN_VALUE : ZERO;

    if (this.isNegative()) {
        if (multiplier.isNegative())
            return this.neg().mul(multiplier.neg());
        else
            return this.neg().mul(multiplier).neg();
    } else if (multiplier.isNegative())
        return this.mul(multiplier.neg()).neg();

    // If both longs are small, use float multiplication
    if (this.lt(TWO_PWR_24) &amp;&amp; multiplier.lt(TWO_PWR_24))
        return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);

    // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.
    // We can skip products that would overflow.

    var a48 = this.high &gt;&gt;&gt; 16;
    var a32 = this.high &amp; 0xFFFF;
    var a16 = this.low &gt;&gt;&gt; 16;
    var a00 = this.low &amp; 0xFFFF;

    var b48 = multiplier.high &gt;&gt;&gt; 16;
    var b32 = multiplier.high &amp; 0xFFFF;
    var b16 = multiplier.low &gt;&gt;&gt; 16;
    var b00 = multiplier.low &amp; 0xFFFF;

    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
    c00 += a00 * b00;
    c16 += c00 &gt;&gt;&gt; 16;
    c00 &amp;= 0xFFFF;
    c16 += a16 * b00;
    c32 += c16 &gt;&gt;&gt; 16;
    c16 &amp;= 0xFFFF;
    c16 += a00 * b16;
    c32 += c16 &gt;&gt;&gt; 16;
    c16 &amp;= 0xFFFF;
    c32 += a32 * b00;
    c48 += c32 &gt;&gt;&gt; 16;
    c32 &amp;= 0xFFFF;
    c32 += a16 * b16;
    c48 += c32 &gt;&gt;&gt; 16;
    c32 &amp;= 0xFFFF;
    c32 += a00 * b32;
    c48 += c32 &gt;&gt;&gt; 16;
    c32 &amp;= 0xFFFF;
    c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
    c48 &amp;= 0xFFFF;
    return fromBits((c16 &lt;&lt; 16) | c00, (c48 &lt;&lt; 16) | c32, this.unsigned);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.Long.prototype.neg" id="apidoc.element.bytebuffer.Long.prototype.neg">
        function <span class="apidocSignatureSpan">bytebuffer.Long.prototype.</span>neg
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function negate() {
    if (!this.unsigned &amp;&amp; this.eq(MIN_VALUE))
        return MIN_VALUE;
    return this.not().add(ONE);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.Long.prototype.negate" id="apidoc.element.bytebuffer.Long.prototype.negate">
        function <span class="apidocSignatureSpan">bytebuffer.Long.prototype.</span>negate
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function negate() {
    if (!this.unsigned &amp;&amp; this.eq(MIN_VALUE))
        return MIN_VALUE;
    return this.not().add(ONE);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.Long.prototype.neq" id="apidoc.element.bytebuffer.Long.prototype.neq">
        function <span class="apidocSignatureSpan">bytebuffer.Long.prototype.</span>neq
        <span class="apidocSignatureSpan">(other)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function notEquals(other) {
    return !this.eq(/* validates */ other);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.Long.prototype.not" id="apidoc.element.bytebuffer.Long.prototype.not">
        function <span class="apidocSignatureSpan">bytebuffer.Long.prototype.</span>not
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function not() {
    return fromBits(~this.low, ~this.high, this.unsigned);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.Long.prototype.notEquals" id="apidoc.element.bytebuffer.Long.prototype.notEquals">
        function <span class="apidocSignatureSpan">bytebuffer.Long.prototype.</span>notEquals
        <span class="apidocSignatureSpan">(other)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function notEquals(other) {
    return !this.eq(/* validates */ other);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.Long.prototype.or" id="apidoc.element.bytebuffer.Long.prototype.or">
        function <span class="apidocSignatureSpan">bytebuffer.Long.prototype.</span>or
        <span class="apidocSignatureSpan">(other)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function or(other) {
    if (!isLong(other))
        other = fromValue(other);
    return fromBits(this.low | other.low, this.high | other.high, this.unsigned);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.Long.prototype.shiftLeft" id="apidoc.element.bytebuffer.Long.prototype.shiftLeft">
        function <span class="apidocSignatureSpan">bytebuffer.Long.prototype.</span>shiftLeft
        <span class="apidocSignatureSpan">(numBits)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function shiftLeft(numBits) {
    if (isLong(numBits))
        numBits = numBits.toInt();
    if ((numBits &amp;= 63) === 0)
        return this;
    else if (numBits &lt; 32)
        return fromBits(this.low &lt;&lt; numBits, (this.high &lt;&lt; numBits) | (this.low &gt;&gt;&gt; (32 - numBits)), this.unsigned);
    else
        return fromBits(0, this.low &lt;&lt; (numBits - 32), this.unsigned);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.Long.prototype.shiftRight" id="apidoc.element.bytebuffer.Long.prototype.shiftRight">
        function <span class="apidocSignatureSpan">bytebuffer.Long.prototype.</span>shiftRight
        <span class="apidocSignatureSpan">(numBits)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function shiftRight(numBits) {
    if (isLong(numBits))
        numBits = numBits.toInt();
    if ((numBits &amp;= 63) === 0)
        return this;
    else if (numBits &lt; 32)
        return fromBits((this.low &gt;&gt;&gt; numBits) | (this.high &lt;&lt; (32 - numBits)), this.high &gt;&gt; numBits, this.unsigned);
    else
        return fromBits(this.high &gt;&gt; (numBits - 32), this.high &gt;= 0 ? 0 : -1, this.unsigned);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.Long.prototype.shiftRightUnsigned" id="apidoc.element.bytebuffer.Long.prototype.shiftRightUnsigned">
        function <span class="apidocSignatureSpan">bytebuffer.Long.prototype.</span>shiftRightUnsigned
        <span class="apidocSignatureSpan">(numBits)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function shiftRightUnsigned(numBits) {
    if (isLong(numBits))
        numBits = numBits.toInt();
    numBits &amp;= 63;
    if (numBits === 0)
        return this;
    else {
        var high = this.high;
        if (numBits &lt; 32) {
            var low = this.low;
            return fromBits((low &gt;&gt;&gt; numBits) | (high &lt;&lt; (32 - numBits)), high &gt;&gt;&gt; numBits, this.unsigned);
        } else if (numBits === 32)
            return fromBits(high, 0, this.unsigned);
        else
            return fromBits(high &gt;&gt;&gt; (numBits - 32), 0, this.unsigned);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.Long.prototype.shl" id="apidoc.element.bytebuffer.Long.prototype.shl">
        function <span class="apidocSignatureSpan">bytebuffer.Long.prototype.</span>shl
        <span class="apidocSignatureSpan">(numBits)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function shiftLeft(numBits) {
    if (isLong(numBits))
        numBits = numBits.toInt();
    if ((numBits &amp;= 63) === 0)
        return this;
    else if (numBits &lt; 32)
        return fromBits(this.low &lt;&lt; numBits, (this.high &lt;&lt; numBits) | (this.low &gt;&gt;&gt; (32 - numBits)), this.unsigned);
    else
        return fromBits(0, this.low &lt;&lt; (numBits - 32), this.unsigned);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.Long.prototype.shr" id="apidoc.element.bytebuffer.Long.prototype.shr">
        function <span class="apidocSignatureSpan">bytebuffer.Long.prototype.</span>shr
        <span class="apidocSignatureSpan">(numBits)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function shiftRight(numBits) {
    if (isLong(numBits))
        numBits = numBits.toInt();
    if ((numBits &amp;= 63) === 0)
        return this;
    else if (numBits &lt; 32)
        return fromBits((this.low &gt;&gt;&gt; numBits) | (this.high &lt;&lt; (32 - numBits)), this.high &gt;&gt; numBits, this.unsigned);
    else
        return fromBits(this.high &gt;&gt; (numBits - 32), this.high &gt;= 0 ? 0 : -1, this.unsigned);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.Long.prototype.shru" id="apidoc.element.bytebuffer.Long.prototype.shru">
        function <span class="apidocSignatureSpan">bytebuffer.Long.prototype.</span>shru
        <span class="apidocSignatureSpan">(numBits)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function shiftRightUnsigned(numBits) {
    if (isLong(numBits))
        numBits = numBits.toInt();
    numBits &amp;= 63;
    if (numBits === 0)
        return this;
    else {
        var high = this.high;
        if (numBits &lt; 32) {
            var low = this.low;
            return fromBits((low &gt;&gt;&gt; numBits) | (high &lt;&lt; (32 - numBits)), high &gt;&gt;&gt; numBits, this.unsigned);
        } else if (numBits === 32)
            return fromBits(high, 0, this.unsigned);
        else
            return fromBits(high &gt;&gt;&gt; (numBits - 32), 0, this.unsigned);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.Long.prototype.sub" id="apidoc.element.bytebuffer.Long.prototype.sub">
        function <span class="apidocSignatureSpan">bytebuffer.Long.prototype.</span>sub
        <span class="apidocSignatureSpan">(subtrahend)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function subtract(subtrahend) {
    if (!isLong(subtrahend))
        subtrahend = fromValue(subtrahend);
    return this.add(subtrahend.neg());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.Long.prototype.subtract" id="apidoc.element.bytebuffer.Long.prototype.subtract">
        function <span class="apidocSignatureSpan">bytebuffer.Long.prototype.</span>subtract
        <span class="apidocSignatureSpan">(subtrahend)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function subtract(subtrahend) {
    if (!isLong(subtrahend))
        subtrahend = fromValue(subtrahend);
    return this.add(subtrahend.neg());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.Long.prototype.toBytes" id="apidoc.element.bytebuffer.Long.prototype.toBytes">
        function <span class="apidocSignatureSpan">bytebuffer.Long.prototype.</span>toBytes
        <span class="apidocSignatureSpan">(le)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toBytes = function (le) {
    return le ? this.toBytesLE() : this.toBytesBE();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.Long.prototype.toBytesBE" id="apidoc.element.bytebuffer.Long.prototype.toBytesBE">
        function <span class="apidocSignatureSpan">bytebuffer.Long.prototype.</span>toBytesBE
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toBytesBE = function () {
    var hi = this.high,
        lo = this.low;
    return [
        (hi &gt;&gt;&gt; 24) &amp; 0xff,
        (hi &gt;&gt;&gt; 16) &amp; 0xff,
        (hi &gt;&gt;&gt;  8) &amp; 0xff,
         hi         &amp; 0xff,
        (lo &gt;&gt;&gt; 24) &amp; 0xff,
        (lo &gt;&gt;&gt; 16) &amp; 0xff,
        (lo &gt;&gt;&gt;  8) &amp; 0xff,
         lo         &amp; 0xff
    ];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.Long.prototype.toBytesLE" id="apidoc.element.bytebuffer.Long.prototype.toBytesLE">
        function <span class="apidocSignatureSpan">bytebuffer.Long.prototype.</span>toBytesLE
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toBytesLE = function () {
    var hi = this.high,
        lo = this.low;
    return [
         lo         &amp; 0xff,
        (lo &gt;&gt;&gt;  8) &amp; 0xff,
        (lo &gt;&gt;&gt; 16) &amp; 0xff,
        (lo &gt;&gt;&gt; 24) &amp; 0xff,
         hi         &amp; 0xff,
        (hi &gt;&gt;&gt;  8) &amp; 0xff,
        (hi &gt;&gt;&gt; 16) &amp; 0xff,
        (hi &gt;&gt;&gt; 24) &amp; 0xff
    ];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.Long.prototype.toInt" id="apidoc.element.bytebuffer.Long.prototype.toInt">
        function <span class="apidocSignatureSpan">bytebuffer.Long.prototype.</span>toInt
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function toInt() {
    return this.unsigned ? this.low &gt;&gt;&gt; 0 : this.low;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.Long.prototype.toNumber" id="apidoc.element.bytebuffer.Long.prototype.toNumber">
        function <span class="apidocSignatureSpan">bytebuffer.Long.prototype.</span>toNumber
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function toNumber() {
    if (this.unsigned)
        return ((this.high &gt;&gt;&gt; 0) * TWO_PWR_32_DBL) + (this.low &gt;&gt;&gt; 0);
    return this.high * TWO_PWR_32_DBL + (this.low &gt;&gt;&gt; 0);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.Long.prototype.toSigned" id="apidoc.element.bytebuffer.Long.prototype.toSigned">
        function <span class="apidocSignatureSpan">bytebuffer.Long.prototype.</span>toSigned
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function toSigned() {
    if (!this.unsigned)
        return this;
    return fromBits(this.low, this.high, false);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (typeof value === 'number') {
        return Long.fromNumber(value, unsigned);
    } else if (typeof value === 'string') {
        return Long.fromString(value, unsigned);
    } else if (value &amp;&amp; value instanceof Long) {
        if (typeof unsigned !== 'undefined') {
            if (unsigned &amp;&amp; !value.unsigned) return value.toUnsigned();
            if (!unsigned &amp;&amp; value.unsigned) return value.<span class="apidocCodeKeywordSpan">toSigned</span>();
        }
        return value;
    } else
        throw TypeError("Illegal value: "+value+" (not an integer or Long)");
}

/**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.Long.prototype.toString" id="apidoc.element.bytebuffer.Long.prototype.toString">
        function <span class="apidocSignatureSpan">bytebuffer.Long.prototype.</span>toString
        <span class="apidocSignatureSpan">(radix)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function toString(radix) {
    radix = radix || 10;
    if (radix &lt; 2 || 36 &lt; radix)
        throw RangeError('radix');
    if (this.isZero())
        return '0';
    if (this.isNegative()) { // Unsigned Longs are never negative
        if (this.eq(MIN_VALUE)) {
            // We need to change the Long value before it can be negated, so we remove
            // the bottom-most digit in this base and then recurse to do the rest.
            var radixLong = fromNumber(radix),
                div = this.div(radixLong),
                rem1 = div.mul(radixLong).sub(this);
            return div.toString(radix) + rem1.toInt().toString(radix);
        } else
            return '-' + this.neg().toString(radix);
    }

    // Do several (6) digits each time through the loop, so as to
    // minimize the calls to the very expensive emulated div.
    var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned),
        rem = this;
    var result = '';
    while (true) {
        var remDiv = rem.div(radixToPower),
            intval = rem.sub(remDiv.mul(radixToPower)).toInt() &gt;&gt;&gt; 0,
            digits = intval.toString(radix);
        rem = remDiv;
        if (rem.isZero())
            return digits + result;
        else {
            while (digits.length &lt; 6)
                digits = '0' + digits;
            result = '' + digits + result;
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.Long.prototype.toUnsigned" id="apidoc.element.bytebuffer.Long.prototype.toUnsigned">
        function <span class="apidocSignatureSpan">bytebuffer.Long.prototype.</span>toUnsigned
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function toUnsigned() {
    if (this.unsigned)
        return this;
    return fromBits(this.low, this.high, true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
function assertLong(value, unsigned) {
    if (typeof value === 'number') {
        return Long.fromNumber(value, unsigned);
    } else if (typeof value === 'string') {
        return Long.fromString(value, unsigned);
    } else if (value &amp;&amp; value instanceof Long) {
        if (typeof unsigned !== 'undefined') {
            if (unsigned &amp;&amp; !value.unsigned) return value.<span class="apidocCodeKeywordSpan">toUnsigned</span>();
            if (!unsigned &amp;&amp; value.unsigned) return value.toSigned();
        }
        return value;
    } else
        throw TypeError("Illegal value: "+value+" (not an integer or Long)");
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.Long.prototype.xor" id="apidoc.element.bytebuffer.Long.prototype.xor">
        function <span class="apidocSignatureSpan">bytebuffer.Long.prototype.</span>xor
        <span class="apidocSignatureSpan">(other)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function xor(other) {
    if (!isLong(other))
        other = fromValue(other);
    return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.bytebuffer.index" id="apidoc.module.bytebuffer.index">module bytebuffer.index</a></h1>










    <h2>
        <a href="#apidoc.element.bytebuffer.index.index" id="apidoc.element.bytebuffer.index.index">
        function <span class="apidocSignatureSpan">bytebuffer.</span>index
        <span class="apidocSignatureSpan">(capacity, littleEndian, noAssert)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">index = function (capacity, littleEndian, noAssert) {
    if (typeof capacity === 'undefined')
        capacity = ByteBuffer.DEFAULT_CAPACITY;
    if (typeof littleEndian === 'undefined')
        littleEndian = ByteBuffer.DEFAULT_ENDIAN;
    if (typeof noAssert === 'undefined')
        noAssert = ByteBuffer.DEFAULT_NOASSERT;
    if (!noAssert) {
        capacity = capacity | 0;
        if (capacity &lt; 0)
            throw RangeError("Illegal capacity");
        littleEndian = !!littleEndian;
        noAssert = !!noAssert;
    }

    /**
     * Backing node Buffer.
     * @type {!Buffer}
     * @expose
     */
    this.buffer = capacity === 0 ? EMPTY_BUFFER : new Buffer(capacity);

    /**
     * Absolute read/write offset.
     * @type {number}
     * @expose
     * @see ByteBuffer#flip
     * @see ByteBuffer#clear
     */
    this.offset = 0;

    /**
     * Marked offset.
     * @type {number}
     * @expose
     * @see ByteBuffer#mark
     * @see ByteBuffer#reset
     */
    this.markedOffset = -1;

    /**
     * Absolute limit of the contained data. Set to the backing buffer's capacity upon allocation.
     * @type {number}
     * @expose
     * @see ByteBuffer#flip
     * @see ByteBuffer#clear
     */
    this.limit = capacity;

    /**
     * Whether to use little endian byte order, defaults to `false` for big endian.
     * @type {boolean}
     * @expose
     */
    this.littleEndian = littleEndian;

    /**
     * Whether to skip assertions of offsets and values, defaults to `false`.
     * @type {boolean}
     * @expose
     */
    this.noAssert = noAssert;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.index.Long" id="apidoc.element.bytebuffer.index.Long">
        function <span class="apidocSignatureSpan">bytebuffer.index.</span>Long
        <span class="apidocSignatureSpan">(low, high, unsigned)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Long(low, high, unsigned) {

    /**
     * The low 32 bits as a signed value.
     * @type {number}
     */
    this.low = low | 0;

    /**
     * The high 32 bits as a signed value.
     * @type {number}
     */
    this.high = high | 0;

    /**
     * Whether unsigned or not.
     * @type {boolean}
     */
    this.unsigned = !!unsigned;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.index.accessor" id="apidoc.element.bytebuffer.index.accessor">
        function <span class="apidocSignatureSpan">bytebuffer.index.</span>accessor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">accessor = function () {
    return Buffer;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.index.allocate" id="apidoc.element.bytebuffer.index.allocate">
        function <span class="apidocSignatureSpan">bytebuffer.index.</span>allocate
        <span class="apidocSignatureSpan">(capacity, littleEndian, noAssert)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">allocate = function (capacity, littleEndian, noAssert) {
    return new ByteBuffer(capacity, littleEndian, noAssert);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.index.atob" id="apidoc.element.bytebuffer.index.atob">
        function <span class="apidocSignatureSpan">bytebuffer.index.</span>atob
        <span class="apidocSignatureSpan">(b64)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">atob = function (b64) {
    return ByteBuffer.fromBase64(b64).toBinary();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.index.btoa" id="apidoc.element.bytebuffer.index.btoa">
        function <span class="apidocSignatureSpan">bytebuffer.index.</span>btoa
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">btoa = function (str) {
    return ByteBuffer.fromBinary(str).toBase64();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.index.calculateString" id="apidoc.element.bytebuffer.index.calculateString">
        function <span class="apidocSignatureSpan">bytebuffer.index.</span>calculateString
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">calculateString = function (str) {
    if (typeof str !== 'string')
        throw TypeError("Illegal argument: "+(typeof str));
    return Buffer.byteLength(str, "utf8");
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.index.calculateUTF8Bytes" id="apidoc.element.bytebuffer.index.calculateUTF8Bytes">
        function <span class="apidocSignatureSpan">bytebuffer.index.</span>calculateUTF8Bytes
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">calculateUTF8Bytes = function (str) {
    if (typeof str !== 'string')
        throw TypeError("Illegal argument: "+(typeof str));
    return Buffer.byteLength(str, "utf8");
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.index.calculateUTF8Chars" id="apidoc.element.bytebuffer.index.calculateUTF8Chars">
        function <span class="apidocSignatureSpan">bytebuffer.index.</span>calculateUTF8Chars
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">calculateUTF8Chars = function (str) {
    return utfx.calculateUTF16asUTF8(stringSource(str))[0];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.index.calculateVarint32" id="apidoc.element.bytebuffer.index.calculateVarint32">
        function <span class="apidocSignatureSpan">bytebuffer.index.</span>calculateVarint32
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">calculateVarint32 = function (value) {
    // ref: src/google/protobuf/io/coded_stream.cc
    value = value &gt;&gt;&gt; 0;
         if (value &lt; 1 &lt;&lt; 7 ) return 1;
    else if (value &lt; 1 &lt;&lt; 14) return 2;
    else if (value &lt; 1 &lt;&lt; 21) return 3;
    else if (value &lt; 1 &lt;&lt; 28) return 4;
    else                      return 5;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.index.calculateVarint64" id="apidoc.element.bytebuffer.index.calculateVarint64">
        function <span class="apidocSignatureSpan">bytebuffer.index.</span>calculateVarint64
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">calculateVarint64 = function (value) {
    if (typeof value === 'number')
        value = Long.fromNumber(value);
    else if (typeof value === 'string')
        value = Long.fromString(value);
    // ref: src/google/protobuf/io/coded_stream.cc
    var part0 = value.toInt() &gt;&gt;&gt; 0,
        part1 = value.shiftRightUnsigned(28).toInt() &gt;&gt;&gt; 0,
        part2 = value.shiftRightUnsigned(56).toInt() &gt;&gt;&gt; 0;
    if (part2 == 0) {
        if (part1 == 0) {
            if (part0 &lt; 1 &lt;&lt; 14)
                return part0 &lt; 1 &lt;&lt; 7 ? 1 : 2;
            else
                return part0 &lt; 1 &lt;&lt; 21 ? 3 : 4;
        } else {
            if (part1 &lt; 1 &lt;&lt; 14)
                return part1 &lt; 1 &lt;&lt; 7 ? 5 : 6;
            else
                return part1 &lt; 1 &lt;&lt; 21 ? 7 : 8;
        }
    } else
        return part2 &lt; 1 &lt;&lt; 7 ? 9 : 10;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.index.concat" id="apidoc.element.bytebuffer.index.concat">
        function <span class="apidocSignatureSpan">bytebuffer.index.</span>concat
        <span class="apidocSignatureSpan">(buffers, encoding, littleEndian, noAssert)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">concat = function (buffers, encoding, littleEndian, noAssert) {
    if (typeof encoding === 'boolean' || typeof encoding !== 'string') {
        noAssert = littleEndian;
        littleEndian = encoding;
        encoding = undefined;
    }
    var capacity = 0;
    for (var i=0, k=buffers.length, length; i&lt;k; ++i) {
        if (!ByteBuffer.isByteBuffer(buffers[i]))
            buffers[i] = ByteBuffer.wrap(buffers[i], encoding);
        length = buffers[i].limit - buffers[i].offset;
        if (length &gt; 0) capacity += length;
    }
    if (capacity === 0)
        return new ByteBuffer(0, littleEndian, noAssert);
    var bb = new ByteBuffer(capacity, littleEndian, noAssert),
        bi;
    i=0; while (i&lt;k) {
        bi = buffers[i++];
        length = bi.limit - bi.offset;
        if (length &lt;= 0) continue;
        bi.buffer.copy(bb.buffer, bb.offset, bi.offset, bi.limit);
        bb.offset += length;
    }
    bb.limit = bb.offset;
    bb.offset = 0;
    return bb;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.index.fromBase64" id="apidoc.element.bytebuffer.index.fromBase64">
        function <span class="apidocSignatureSpan">bytebuffer.index.</span>fromBase64
        <span class="apidocSignatureSpan">(str, littleEndian)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fromBase64 = function (str, littleEndian) {
    return ByteBuffer.wrap(new Buffer(str, "base64"), littleEndian);
    return bb;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.index.fromBinary" id="apidoc.element.bytebuffer.index.fromBinary">
        function <span class="apidocSignatureSpan">bytebuffer.index.</span>fromBinary
        <span class="apidocSignatureSpan">(str, littleEndian)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fromBinary = function (str, littleEndian) {
    return ByteBuffer.wrap(new Buffer(str, "binary"), littleEndian);
    return bb;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.index.fromDebug" id="apidoc.element.bytebuffer.index.fromDebug">
        function <span class="apidocSignatureSpan">bytebuffer.index.</span>fromDebug
        <span class="apidocSignatureSpan">(str, littleEndian, noAssert)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fromDebug = function (str, littleEndian, noAssert) {
    var k = str.length,
        bb = new ByteBuffer(((k+1)/3)|0, littleEndian, noAssert);
    var i = 0, j = 0, ch, b,
        rs = false, // Require symbol next
        ho = false, hm = false, hl = false, // Already has offset (ho), markedOffset (hm), limit (hl)?
        fail = false;
    while (i&lt;k) {
        switch (ch = str.charAt(i++)) {
            case '!':
                if (!noAssert) {
                    if (ho || hm || hl) {
                        fail = true;
                        break;
                    }
                    ho = hm = hl = true;
                }
                bb.offset = bb.markedOffset = bb.limit = j;
                rs = false;
                break;
            case '|':
                if (!noAssert) {
                    if (ho || hl) {
                        fail = true;
                        break;
                    }
                    ho = hl = true;
                }
                bb.offset = bb.limit = j;
                rs = false;
                break;
            case '[':
                if (!noAssert) {
                    if (ho || hm) {
                        fail = true;
                        break;
                    }
                    ho = hm = true;
                }
                bb.offset = bb.markedOffset = j;
                rs = false;
                break;
            case '&lt;':
                if (!noAssert) {
                    if (ho) {
                        fail = true;
                        break;
                    }
                    ho = true;
                }
                bb.offset = j;
                rs = false;
                break;
            case ']':
                if (!noAssert) {
                    if (hl || hm) {
                        fail = true;
                        break;
                    }
                    hl = hm = true;
                }
                bb.limit = bb.markedOffset = j;
                rs = false;
                break;
            case '&gt;':
                if (!noAssert) {
                    if (hl) {
                        fail = true;
                        break;
                    }
                    hl = true;
                }
                bb.limit = j;
                rs = false;
                break;
            case "'":
                if (!noAssert) {
                    if (hm) {
                        fail = true;
                        break;
                    }
                    hm = true;
                }
                bb.markedOffset = j;
                rs = false;
                break;
            case ' ':
                rs = false;
                break;
            default:
                if (!noAssert) {
                    if (rs) {
                        fail = true;
                        break;
                    }
                }
                b = parseInt(ch+str.charAt(i++), 16);
                if (!noAssert) {
                    if (isNaN(b) || b &lt; 0 || b &gt; 255)
                        throw TypeError("Illegal str: Not a debug encoded string");
                }
                bb.buffer[j++] = b;
                rs = true;
        }
        if (fail)
            throw TypeError("Illegal str: Invalid symbol at "+i);
    }
    if (!noAssert) {
        if (!ho || !hl)
            throw TypeError("Illegal str: Missing offset or limit");
        if (j&lt;bb.buffer.length)
            throw TypeError("Illegal str: Not a debug encoded string (is it hex?) "+j+" &lt; "+k);
    }
    return bb;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.index.fromHex" id="apidoc.element.bytebuffer.index.fromHex">
        function <span class="apidocSignatureSpan">bytebuffer.index.</span>fromHex
        <span class="apidocSignatureSpan">(str, littleEndian, noAssert)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fromHex = function (str, littleEndian, noAssert) {
    if (!noAssert) {
        if (typeof str !== 'string')
            throw TypeError("Illegal str: Not a string");
        if (str.length % 2 !== 0)
            throw TypeError("Illegal str: Length not a multiple of 2");
    }
    var bb = new ByteBuffer(0, littleEndian, true);
    bb.buffer = new Buffer(str, "hex");
    bb.limit = bb.buffer.length;
    return bb;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.index.fromUTF8" id="apidoc.element.bytebuffer.index.fromUTF8">
        function <span class="apidocSignatureSpan">bytebuffer.index.</span>fromUTF8
        <span class="apidocSignatureSpan">(str, littleEndian, noAssert)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fromUTF8 = function (str, littleEndian, noAssert) {
    if (!noAssert)
        if (typeof str !== 'string')
            throw TypeError("Illegal str: Not a string");
    var bb = new ByteBuffer(0, littleEndian, noAssert);
    bb.buffer = new Buffer(str, "utf8");
    bb.limit = bb.buffer.length;
    return bb;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.index.isByteBuffer" id="apidoc.element.bytebuffer.index.isByteBuffer">
        function <span class="apidocSignatureSpan">bytebuffer.index.</span>isByteBuffer
        <span class="apidocSignatureSpan">(bb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isByteBuffer = function (bb) {
    return (bb &amp;&amp; bb["__isByteBuffer__"]) === true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.index.type" id="apidoc.element.bytebuffer.index.type">
        function <span class="apidocSignatureSpan">bytebuffer.index.</span>type
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">type = function () {
    return Buffer;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.index.wrap" id="apidoc.element.bytebuffer.index.wrap">
        function <span class="apidocSignatureSpan">bytebuffer.index.</span>wrap
        <span class="apidocSignatureSpan">(buffer, encoding, littleEndian, noAssert)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">wrap = function (buffer, encoding, littleEndian, noAssert) {
    if (typeof encoding !== 'string') {
        noAssert = littleEndian;
        littleEndian = encoding;
        encoding = undefined;
    }
    if (typeof buffer === 'string') {
        if (typeof encoding === 'undefined')
            encoding = "utf8";
        switch (encoding) {
            case "base64":
                return ByteBuffer.fromBase64(buffer, littleEndian);
            case "hex":
                return ByteBuffer.fromHex(buffer, littleEndian);
            case "binary":
                return ByteBuffer.fromBinary(buffer, littleEndian);
            case "utf8":
                return ByteBuffer.fromUTF8(buffer, littleEndian);
            case "debug":
                return ByteBuffer.fromDebug(buffer, littleEndian);
            default:
                throw Error("Unsupported encoding: "+encoding);
        }
    }
    if (buffer === null || typeof buffer !== 'object')
        throw TypeError("Illegal buffer");
    var bb;
    if (ByteBuffer.isByteBuffer(buffer)) {
        bb = ByteBufferPrototype.clone.call(buffer);
        bb.markedOffset = -1;
        return bb;
    }
    var i = 0,
        k = 0,
        b;
    if (buffer instanceof Uint8Array) { // Extract bytes from Uint8Array
        b = new Buffer(buffer.length);
        if (memcpy) { // Fast
            memcpy(b, 0, buffer.buffer, buffer.byteOffset, buffer.byteOffset + buffer.length);
        } else { // Slow
            for (i=0, k=buffer.length; i&lt;k; ++i)
                b[i] = buffer[i];
        }
        buffer = b;
    } else if (buffer instanceof ArrayBuffer) { // Convert ArrayBuffer to Buffer
        b = new Buffer(buffer.byteLength);
        if (memcpy) { // Fast
            memcpy(b, 0, buffer, 0, buffer.byteLength);
        } else { // Slow
            buffer = new Uint8Array(buffer);
            for (i=0, k=buffer.length; i&lt;k; ++i) {
                b[i] = buffer[i];
            }
        }
        buffer = b;
    } else if (!(buffer instanceof Buffer)) { // Create from octets if it is an error, otherwise fail
        if (Object.prototype.toString.call(buffer) !== "[object Array]")
            throw TypeError("Illegal buffer");
        buffer = new Buffer(buffer);
    }
    bb = new ByteBuffer(0, littleEndian, noAssert);
    if (buffer.length &gt; 0) { // Avoid references to more than one EMPTY_BUFFER
        bb.buffer = buffer;
        bb.limit = buffer.length;
    }
    return bb;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.index.zigZagDecode32" id="apidoc.element.bytebuffer.index.zigZagDecode32">
        function <span class="apidocSignatureSpan">bytebuffer.index.</span>zigZagDecode32
        <span class="apidocSignatureSpan">(n)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">zigZagDecode32 = function (n) {
    return ((n &gt;&gt;&gt; 1) ^ -(n &amp; 1)) | 0; // // ref: src/google/protobuf/wire_format_lite.h
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.index.zigZagDecode64" id="apidoc.element.bytebuffer.index.zigZagDecode64">
        function <span class="apidocSignatureSpan">bytebuffer.index.</span>zigZagDecode64
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">zigZagDecode64 = function (value) {
    if (typeof value === 'number')
        value = Long.fromNumber(value, false);
    else if (typeof value === 'string')
        value = Long.fromString(value, false);
    else if (value.unsigned !== false) value = value.toSigned();
    // ref: src/google/protobuf/wire_format_lite.h
    return value.shiftRightUnsigned(1).xor(value.and(Long.ONE).toSigned().negate()).toSigned();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.index.zigZagEncode32" id="apidoc.element.bytebuffer.index.zigZagEncode32">
        function <span class="apidocSignatureSpan">bytebuffer.index.</span>zigZagEncode32
        <span class="apidocSignatureSpan">(n)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">zigZagEncode32 = function (n) {
    return (((n |= 0) &lt;&lt; 1) ^ (n &gt;&gt; 31)) &gt;&gt;&gt; 0; // ref: src/google/protobuf/wire_format_lite.h
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.index.zigZagEncode64" id="apidoc.element.bytebuffer.index.zigZagEncode64">
        function <span class="apidocSignatureSpan">bytebuffer.index.</span>zigZagEncode64
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">zigZagEncode64 = function (value) {
    if (typeof value === 'number')
        value = Long.fromNumber(value, false);
    else if (typeof value === 'string')
        value = Long.fromString(value, false);
    else if (value.unsigned !== false) value = value.toSigned();
    // ref: src/google/protobuf/wire_format_lite.h
    return value.shiftLeft(1).xor(value.shiftRight(63)).toUnsigned();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>
















</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.bytebuffer.index.prototype" id="apidoc.module.bytebuffer.index.prototype">module bytebuffer.index.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.bytebuffer.index.prototype.BE" id="apidoc.element.bytebuffer.index.prototype.BE">
        function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>BE
        <span class="apidocSignatureSpan">(bigEndian)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">BE = function (bigEndian) {
    this.littleEndian = typeof bigEndian !== 'undefined' ? !bigEndian : false;
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.index.prototype.LE" id="apidoc.element.bytebuffer.index.prototype.LE">
        function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>LE
        <span class="apidocSignatureSpan">(littleEndian)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">LE = function (littleEndian) {
    this.littleEndian = typeof littleEndian !== 'undefined' ? !!littleEndian : true;
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.index.prototype.append" id="apidoc.element.bytebuffer.index.prototype.append">
        function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>append
        <span class="apidocSignatureSpan">(source, encoding, offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">append = function (source, encoding, offset) {
    if (typeof encoding === 'number' || typeof encoding !== 'string') {
        offset = encoding;
        encoding = undefined;
    }
    var relative = typeof offset === 'undefined';
    if (relative) offset = this.offset;
    if (!this.noAssert) {
        if (typeof offset !== 'number' || offset % 1 !== 0)
            throw TypeError("Illegal offset: "+offset+" (not an integer)");
        offset &gt;&gt;&gt;= 0;
        if (offset &lt; 0 || offset + 0 &gt; this.buffer.length)
            throw RangeError("Illegal offset: 0 &lt;= "+offset+" (+"+0+") &lt;= "+this.buffer.length);
    }
    if (!(source instanceof ByteBuffer))
        source = ByteBuffer.wrap(source, encoding);
    var length = source.limit - source.offset;
    if (length &lt;= 0) return this; // Nothing to append
    offset += length;
    var capacity16 = this.buffer.length;
    if (offset &gt; capacity16)
        this.resize((capacity16 *= 2) &gt; offset ? capacity16 : offset);
    offset -= length;
    source.buffer.copy(this.buffer, offset, source.offset, source.limit);
    source.offset += length;
    if (relative) this.offset += length;
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.index.prototype.appendTo" id="apidoc.element.bytebuffer.index.prototype.appendTo">
        function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>appendTo
        <span class="apidocSignatureSpan">(target, offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">appendTo = function (target, offset) {
    target.append(this, offset);
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.index.prototype.assert" id="apidoc.element.bytebuffer.index.prototype.assert">
        function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>assert
        <span class="apidocSignatureSpan">(assert)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">assert = function (assert) {
    this.noAssert = !assert;
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.index.prototype.capacity" id="apidoc.element.bytebuffer.index.prototype.capacity">
        function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>capacity
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">capacity = function () {
    return this.buffer.length;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.index.prototype.clear" id="apidoc.element.bytebuffer.index.prototype.clear">
        function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>clear
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clear = function () {
    this.offset = 0;
    this.limit = this.buffer.length;
    this.markedOffset = -1;
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.index.prototype.clone" id="apidoc.element.bytebuffer.index.prototype.clone">
        function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>clone
        <span class="apidocSignatureSpan">(copy)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clone = function (copy) {
    var bb = new ByteBuffer(0, this.littleEndian, this.noAssert);
    if (copy) {
        var buffer = new Buffer(this.buffer.length);
        this.buffer.copy(buffer);
        bb.buffer = buffer;
    } else {
        bb.buffer = this.buffer;
    }
    bb.offset = this.offset;
    bb.markedOffset = this.markedOffset;
    bb.limit = this.limit;
    return bb;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.index.prototype.compact" id="apidoc.element.bytebuffer.index.prototype.compact">
        function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>compact
        <span class="apidocSignatureSpan">(begin, end)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compact = function (begin, end) {
    if (typeof begin === 'undefined') begin = this.offset;
    if (typeof end === 'undefined') end = this.limit;
    if (!this.noAssert) {
        if (typeof begin !== 'number' || begin % 1 !== 0)
            throw TypeError("Illegal begin: Not an integer");
        begin &gt;&gt;&gt;= 0;
        if (typeof end !== 'number' || end % 1 !== 0)
            throw TypeError("Illegal end: Not an integer");
        end &gt;&gt;&gt;= 0;
        if (begin &lt; 0 || begin &gt; end || end &gt; this.buffer.length)
            throw RangeError("Illegal range: 0 &lt;= "+begin+" &lt;= "+end+" &lt;= "+this.buffer.length);
    }
    if (begin === 0 &amp;&amp; end === this.buffer.length)
        return this; // Already compacted
    var len = end - begin;
    if (len === 0) {
        this.buffer = EMPTY_BUFFER;
        if (this.markedOffset &gt;= 0) this.markedOffset -= begin;
        this.offset = 0;
        this.limit = 0;
        return this;
    }
    var buffer = new Buffer(len);
    this.buffer.copy(buffer, 0, begin, end);
    this.buffer = buffer;
    if (this.markedOffset &gt;= 0) this.markedOffset -= begin;
    this.offset = 0;
    this.limit = len;
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.index.prototype.copy" id="apidoc.element.bytebuffer.index.prototype.copy">
        function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>copy
        <span class="apidocSignatureSpan">(begin, end)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">copy = function (begin, end) {
    if (typeof begin === 'undefined') begin = this.offset;
    if (typeof end === 'undefined') end = this.limit;
    if (!this.noAssert) {
        if (typeof begin !== 'number' || begin % 1 !== 0)
            throw TypeError("Illegal begin: Not an integer");
        begin &gt;&gt;&gt;= 0;
        if (typeof end !== 'number' || end % 1 !== 0)
            throw TypeError("Illegal end: Not an integer");
        end &gt;&gt;&gt;= 0;
        if (begin &lt; 0 || begin &gt; end || end &gt; this.buffer.length)
            throw RangeError("Illegal range: 0 &lt;= "+begin+" &lt;= "+end+" &lt;= "+this.buffer.length);
    }
    if (begin === end)
        return new ByteBuffer(0, this.littleEndian, this.noAssert);
    var capacity = end - begin,
        bb = new ByteBuffer(capacity, this.littleEndian, this.noAssert);
    bb.offset = 0;
    bb.limit = capacity;
    if (bb.markedOffset &gt;= 0) bb.markedOffset -= begin;
    this.copyTo(bb, 0, begin, end);
    return bb;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.index.prototype.copyTo" id="apidoc.element.bytebuffer.index.prototype.copyTo">
        function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>copyTo
        <span class="apidocSignatureSpan">(target, targetOffset, sourceOffset, sourceLimit)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">copyTo = function (target, targetOffset, sourceOffset, sourceLimit) {
    var relative,
        targetRelative;
    if (!this.noAssert) {
        if (!ByteBuffer.isByteBuffer(target))
            throw TypeError("Illegal target: Not a ByteBuffer");
    }
    targetOffset = (targetRelative = typeof targetOffset === 'undefined') ? target.offset : targetOffset | 0;
    sourceOffset = (relative = typeof sourceOffset === 'undefined') ? this.offset : sourceOffset | 0;
    sourceLimit = typeof sourceLimit === 'undefined' ? this.limit : sourceLimit | 0;

    if (targetOffset &lt; 0 || targetOffset &gt; target.buffer.length)
        throw RangeError("Illegal target range: 0 &lt;= "+targetOffset+" &lt;= "+target.buffer.length);
    if (sourceOffset &lt; 0 || sourceLimit &gt; this.buffer.length)
        throw RangeError("Illegal source range: 0 &lt;= "+sourceOffset+" &lt;= "+this.buffer.length);

    var len = sourceLimit - sourceOffset;
    if (len === 0)
        return target; // Nothing to copy

    target.ensureCapacity(targetOffset + len);

    this.buffer.copy(target.buffer, targetOffset, sourceOffset, sourceLimit);

    if (relative) this.offset += len;
    if (targetRelative) target.offset += len;

    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.index.prototype.ensureCapacity" id="apidoc.element.bytebuffer.index.prototype.ensureCapacity">
        function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>ensureCapacity
        <span class="apidocSignatureSpan">(capacity)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ensureCapacity = function (capacity) {
    var current = this.buffer.length;
    if (current &lt; capacity)
        return this.resize((current *= 2) &gt; capacity ? current : capacity);
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.index.prototype.fill" id="apidoc.element.bytebuffer.index.prototype.fill">
        function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>fill
        <span class="apidocSignatureSpan">(value, begin, end)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fill = function (value, begin, end) {
    var relative = typeof begin === 'undefined';
    if (relative) begin = this.offset;
    if (typeof value === 'string' &amp;&amp; value.length &gt; 0)
        value = value.charCodeAt(0);
    if (typeof begin === 'undefined') begin = this.offset;
    if (typeof end === 'undefined') end = this.limit;
    if (!this.noAssert) {
        if (typeof value !== 'number' || value % 1 !== 0)
            throw TypeError("Illegal value: "+value+" (not an integer)");
        value |= 0;
        if (typeof begin !== 'number' || begin % 1 !== 0)
            throw TypeError("Illegal begin: Not an integer");
        begin &gt;&gt;&gt;= 0;
        if (typeof end !== 'number' || end % 1 !== 0)
            throw TypeError("Illegal end: Not an integer");
        end &gt;&gt;&gt;= 0;
        if (begin &lt; 0 || begin &gt; end || end &gt; this.buffer.length)
            throw RangeError("Illegal range: 0 &lt;= "+begin+" &lt;= "+end+" &lt;= "+this.buffer.length);
    }
    if (begin &gt;= end)
        return this; // Nothing to fill
    this.buffer.fill(value, begin, end);
    begin = end;
    if (relative) this.offset = begin;
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.index.prototype.flip" id="apidoc.element.bytebuffer.index.prototype.flip">
        function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>flip
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">flip = function () {
    this.limit = this.offset;
    this.offset = 0;
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
available.

```javascript
var ByteBuffer = require("bytebuffer");

var bb = new ByteBuffer()
            .writeIString("Hello world!")
            .<span class="apidocCodeKeywordSpan">flip</span>();
console.log(bb.readIString()+" from bytebuffer.js");
```

In the browser, 64 bit integer support is optional and present only if [Long.js](https://github.com/dcodeIO/long.js) has
been loaded prior to bytebuffer.js.

API
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.index.prototype.mark" id="apidoc.element.bytebuffer.index.prototype.mark">
        function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>mark
        <span class="apidocSignatureSpan">(offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mark = function (offset) {
    offset = typeof offset === 'undefined' ? this.offset : offset;
    if (!this.noAssert) {
        if (typeof offset !== 'number' || offset % 1 !== 0)
            throw TypeError("Illegal offset: "+offset+" (not an integer)");
        offset &gt;&gt;&gt;= 0;
        if (offset &lt; 0 || offset + 0 &gt; this.buffer.length)
            throw RangeError("Illegal offset: 0 &lt;= "+offset+" (+"+0+") &lt;= "+this.buffer.length);
    }
    this.markedOffset = offset;
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.index.prototype.order" id="apidoc.element.bytebuffer.index.prototype.order">
        function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>order
        <span class="apidocSignatureSpan">(littleEndian)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">order = function (littleEndian) {
    if (!this.noAssert) {
        if (typeof littleEndian !== 'boolean')
            throw TypeError("Illegal littleEndian: Not a boolean");
    }
    this.littleEndian = !!littleEndian;
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.index.prototype.prepend" id="apidoc.element.bytebuffer.index.prototype.prepend">
        function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>prepend
        <span class="apidocSignatureSpan">(source, encoding, offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">prepend = function (source, encoding, offset) {
    if (typeof encoding === 'number' || typeof encoding !== 'string') {
        offset = encoding;
        encoding = undefined;
    }
    var relative = typeof offset === 'undefined';
    if (relative) offset = this.offset;
    if (!this.noAssert) {
        if (typeof offset !== 'number' || offset % 1 !== 0)
            throw TypeError("Illegal offset: "+offset+" (not an integer)");
        offset &gt;&gt;&gt;= 0;
        if (offset &lt; 0 || offset + 0 &gt; this.buffer.length)
            throw RangeError("Illegal offset: 0 &lt;= "+offset+" (+"+0+") &lt;= "+this.buffer.length);
    }
    if (!(source instanceof ByteBuffer))
        source = ByteBuffer.wrap(source, encoding);
    var len = source.limit - source.offset;
    if (len &lt;= 0) return this; // Nothing to prepend
    var diff = len - offset;
    if (diff &gt; 0) { // Not enough space before offset, so resize + move
        var buffer = new Buffer(this.buffer.length + diff);
        this.buffer.copy(buffer, len, offset, this.buffer.length);
        this.buffer = buffer;
        this.offset += diff;
        if (this.markedOffset &gt;= 0) this.markedOffset += diff;
        this.limit += diff;
        offset += diff;
    }        source.buffer.copy(this.buffer, offset - len, source.offset, source.limit);

    source.offset = source.limit;
    if (relative)
        this.offset -= len;
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.index.prototype.prependTo" id="apidoc.element.bytebuffer.index.prototype.prependTo">
        function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>prependTo
        <span class="apidocSignatureSpan">(target, offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">prependTo = function (target, offset) {
    target.prepend(this, offset);
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.index.prototype.printDebug" id="apidoc.element.bytebuffer.index.prototype.printDebug">
        function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>printDebug
        <span class="apidocSignatureSpan">(out)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">printDebug = function (out) {
    if (typeof out !== 'function') out = console.log.bind(console);
    out(
        this.toString()+"\n"+
        "-------------------------------------------------------------------\n"+
        this.toDebug(/* columns */ true)
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.index.prototype.readBitSet" id="apidoc.element.bytebuffer.index.prototype.readBitSet">
        function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>readBitSet
        <span class="apidocSignatureSpan">(offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readBitSet = function (offset) {
  var relative = typeof offset === 'undefined';
  if (relative) offset = this.offset;

  var ret = this.readVarint32(offset),
      bits = ret.value,
      bytes = (bits &gt;&gt; 3),
      bit = 0,
      value = [],
      k;

  offset += ret.length;

  while(bytes--) {
    k = this.readByte(offset++);
    value[bit++] = !!(k &amp; 0x01);
    value[bit++] = !!(k &amp; 0x02);
    value[bit++] = !!(k &amp; 0x04);
    value[bit++] = !!(k &amp; 0x08);
    value[bit++] = !!(k &amp; 0x10);
    value[bit++] = !!(k &amp; 0x20);
    value[bit++] = !!(k &amp; 0x40);
    value[bit++] = !!(k &amp; 0x80);
  }

  if(bit &lt; bits) {
    var m = 0;
    k = this.readByte(offset++);
    while(bit &lt; bits) value[bit++] = !!((k &gt;&gt; (m++)) &amp; 1);
  }

  if (relative) {
    this.offset = offset;
  }
  return value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.index.prototype.readByte" id="apidoc.element.bytebuffer.index.prototype.readByte">
        function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>readByte
        <span class="apidocSignatureSpan">(offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readByte = function (offset) {
    var relative = typeof offset === 'undefined';
    if (relative) offset = this.offset;
    if (!this.noAssert) {
        if (typeof offset !== 'number' || offset % 1 !== 0)
            throw TypeError("Illegal offset: "+offset+" (not an integer)");
        offset &gt;&gt;&gt;= 0;
        if (offset &lt; 0 || offset + 1 &gt; this.buffer.length)
            throw RangeError("Illegal offset: 0 &lt;= "+offset+" (+"+1+") &lt;= "+this.buffer.length);
    }
    var value = this.buffer[offset];
    if ((value &amp; 0x80) === 0x80) value = -(0xFF - value + 1); // Cast to signed
    if (relative) this.offset += 1;
    return value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.index.prototype.readBytes" id="apidoc.element.bytebuffer.index.prototype.readBytes">
        function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>readBytes
        <span class="apidocSignatureSpan">(length, offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readBytes = function (length, offset) {
    var relative = typeof offset === 'undefined';
    if (relative) offset = this.offset;
    if (!this.noAssert) {
        if (typeof offset !== 'number' || offset % 1 !== 0)
            throw TypeError("Illegal offset: "+offset+" (not an integer)");
        offset &gt;&gt;&gt;= 0;
        if (offset &lt; 0 || offset + length &gt; this.buffer.length)
            throw RangeError("Illegal offset: 0 &lt;= "+offset+" (+"+length+") &lt;= "+this.buffer.length);
    }
    var slice = this.slice(offset, offset + length);
    if (relative) this.offset += length;
    return slice;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.index.prototype.readCString" id="apidoc.element.bytebuffer.index.prototype.readCString">
        function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>readCString
        <span class="apidocSignatureSpan">(offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readCString = function (offset) {
    var relative = typeof offset === 'undefined';
    if (relative) offset = this.offset;
    if (!this.noAssert) {
        if (typeof offset !== 'number' || offset % 1 !== 0)
            throw TypeError("Illegal offset: "+offset+" (not an integer)");
        offset &gt;&gt;&gt;= 0;
        if (offset &lt; 0 || offset + 1 &gt; this.buffer.length)
            throw RangeError("Illegal offset: 0 &lt;= "+offset+" (+"+1+") &lt;= "+this.buffer.length);
    }
    var start = offset,
        temp;
    // UTF8 strings do not contain zero bytes in between except for the zero character itself, so:
    do {
        if (offset &gt;= this.buffer.length)
            throw RangeError("Index out of range: "+offset+" &lt;= "+this.buffer.length);
        temp = this.buffer[offset++];
    } while (temp !== 0);
    var str = this.buffer.toString("utf8", start, offset-1);
    if (relative) {
        this.offset = offset;
        return str;
    } else {
        return {
            "string": str,
            "length": offset - start
        };
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.index.prototype.readDouble" id="apidoc.element.bytebuffer.index.prototype.readDouble">
        function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>readDouble
        <span class="apidocSignatureSpan">(offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readDouble = function (offset) {
    var relative = typeof offset === 'undefined';
    if (relative) offset = this.offset;
    if (!this.noAssert) {
        if (typeof offset !== 'number' || offset % 1 !== 0)
            throw TypeError("Illegal offset: "+offset+" (not an integer)");
        offset &gt;&gt;&gt;= 0;
        if (offset &lt; 0 || offset + 8 &gt; this.buffer.length)
            throw RangeError("Illegal offset: 0 &lt;= "+offset+" (+"+8+") &lt;= "+this.buffer.length);
    }
    var value = this.littleEndian
        ? this.buffer.readDoubleLE(offset, true)
        : this.buffer.readDoubleBE(offset, true);
    if (relative) this.offset += 8;
    return value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.index.prototype.readFloat" id="apidoc.element.bytebuffer.index.prototype.readFloat">
        function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>readFloat
        <span class="apidocSignatureSpan">(offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readFloat = function (offset) {
    var relative = typeof offset === 'undefined';
    if (relative) offset = this.offset;
    if (!this.noAssert) {
        if (typeof offset !== 'number' || offset % 1 !== 0)
            throw TypeError("Illegal offset: "+offset+" (not an integer)");
        offset &gt;&gt;&gt;= 0;
        if (offset &lt; 0 || offset + 4 &gt; this.buffer.length)
            throw RangeError("Illegal offset: 0 &lt;= "+offset+" (+"+4+") &lt;= "+this.buffer.length);
    }
    var value = this.littleEndian
        ? this.buffer.readFloatLE(offset, true)
        : this.buffer.readFloatBE(offset, true);
    if (relative) this.offset += 4;
    return value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.index.prototype.readFloat32" id="apidoc.element.bytebuffer.index.prototype.readFloat32">
        function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>readFloat32
        <span class="apidocSignatureSpan">(offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readFloat32 = function (offset) {
    var relative = typeof offset === 'undefined';
    if (relative) offset = this.offset;
    if (!this.noAssert) {
        if (typeof offset !== 'number' || offset % 1 !== 0)
            throw TypeError("Illegal offset: "+offset+" (not an integer)");
        offset &gt;&gt;&gt;= 0;
        if (offset &lt; 0 || offset + 4 &gt; this.buffer.length)
            throw RangeError("Illegal offset: 0 &lt;= "+offset+" (+"+4+") &lt;= "+this.buffer.length);
    }
    var value = this.littleEndian
        ? this.buffer.readFloatLE(offset, true)
        : this.buffer.readFloatBE(offset, true);
    if (relative) this.offset += 4;
    return value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.index.prototype.readFloat64" id="apidoc.element.bytebuffer.index.prototype.readFloat64">
        function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>readFloat64
        <span class="apidocSignatureSpan">(offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readFloat64 = function (offset) {
    var relative = typeof offset === 'undefined';
    if (relative) offset = this.offset;
    if (!this.noAssert) {
        if (typeof offset !== 'number' || offset % 1 !== 0)
            throw TypeError("Illegal offset: "+offset+" (not an integer)");
        offset &gt;&gt;&gt;= 0;
        if (offset &lt; 0 || offset + 8 &gt; this.buffer.length)
            throw RangeError("Illegal offset: 0 &lt;= "+offset+" (+"+8+") &lt;= "+this.buffer.length);
    }
    var value = this.littleEndian
        ? this.buffer.readDoubleLE(offset, true)
        : this.buffer.readDoubleBE(offset, true);
    if (relative) this.offset += 8;
    return value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.index.prototype.readIString" id="apidoc.element.bytebuffer.index.prototype.readIString">
        function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>readIString
        <span class="apidocSignatureSpan">(offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readIString = function (offset) {
    var relative = typeof offset === 'undefined';
    if (relative) offset = this.offset;
    if (!this.noAssert) {
        if (typeof offset !== 'number' || offset % 1 !== 0)
            throw TypeError("Illegal offset: "+offset+" (not an integer)");
        offset &gt;&gt;&gt;= 0;
        if (offset &lt; 0 || offset + 4 &gt; this.buffer.length)
            throw RangeError("Illegal offset: 0 &lt;= "+offset+" (+"+4+") &lt;= "+this.buffer.length);
    }
    var start = offset;
    var len = this.readUint32(offset);
    var str = this.readUTF8String(len, ByteBuffer.METRICS_BYTES, offset += 4);
    offset += str['length'];
    if (relative) {
        this.offset = offset;
        return str['string'];
    } else {
        return {
            'string': str['string'],
            'length': offset - start
        };
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

```javascript
var ByteBuffer = require("bytebuffer");

var bb = new ByteBuffer()
            .writeIString("Hello world!")
            .flip();
console.log(bb.<span class="apidocCodeKeywordSpan">readIString</span>()+" from bytebuffer.js");
```

In the browser, 64 bit integer support is optional and present only if [Long.js](https://github.com/dcodeIO/long.js) has
been loaded prior to bytebuffer.js.

API
---
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.index.prototype.readInt" id="apidoc.element.bytebuffer.index.prototype.readInt">
        function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>readInt
        <span class="apidocSignatureSpan">(offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readInt = function (offset) {
    var relative = typeof offset === 'undefined';
    if (relative) offset = this.offset;
    if (!this.noAssert) {
        if (typeof offset !== 'number' || offset % 1 !== 0)
            throw TypeError("Illegal offset: "+offset+" (not an integer)");
        offset &gt;&gt;&gt;= 0;
        if (offset &lt; 0 || offset + 4 &gt; this.buffer.length)
            throw RangeError("Illegal offset: 0 &lt;= "+offset+" (+"+4+") &lt;= "+this.buffer.length);
    }
    var value = 0;
    if (this.littleEndian) {
        value  = this.buffer[offset+2] &lt;&lt; 16;
        value |= this.buffer[offset+1] &lt;&lt;  8;
        value |= this.buffer[offset  ];
        value += this.buffer[offset+3] &lt;&lt; 24 &gt;&gt;&gt; 0;
    } else {
        value  = this.buffer[offset+1] &lt;&lt; 16;
        value |= this.buffer[offset+2] &lt;&lt;  8;
        value |= this.buffer[offset+3];
        value += this.buffer[offset  ] &lt;&lt; 24 &gt;&gt;&gt; 0;
    }
    value |= 0; // Cast to signed
    if (relative) this.offset += 4;
    return value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.index.prototype.readInt16" id="apidoc.element.bytebuffer.index.prototype.readInt16">
        function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>readInt16
        <span class="apidocSignatureSpan">(offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readInt16 = function (offset) {
    var relative = typeof offset === 'undefined';
    if (relative) offset = this.offset;
    if (!this.noAssert) {
        if (typeof offset !== 'number' || offset % 1 !== 0)
            throw TypeError("Illegal offset: "+offset+" (not an integer)");
        offset &gt;&gt;&gt;= 0;
        if (offset &lt; 0 || offset + 2 &gt; this.buffer.length)
            throw RangeError("Illegal offset: 0 &lt;= "+offset+" (+"+2+") &lt;= "+this.buffer.length);
    }
    var value = 0;
    if (this.littleEndian) {
        value  = this.buffer[offset  ];
        value |= this.buffer[offset+1] &lt;&lt; 8;
    } else {
        value  = this.buffer[offset  ] &lt;&lt; 8;
        value |= this.buffer[offset+1];
    }
    if ((value &amp; 0x8000) === 0x8000) value = -(0xFFFF - value + 1); // Cast to signed
    if (relative) this.offset += 2;
    return value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.index.prototype.readInt32" id="apidoc.element.bytebuffer.index.prototype.readInt32">
        function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>readInt32
        <span class="apidocSignatureSpan">(offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readInt32 = function (offset) {
    var relative = typeof offset === 'undefined';
    if (relative) offset = this.offset;
    if (!this.noAssert) {
        if (typeof offset !== 'number' || offset % 1 !== 0)
            throw TypeError("Illegal offset: "+offset+" (not an integer)");
        offset &gt;&gt;&gt;= 0;
        if (offset &lt; 0 || offset + 4 &gt; this.buffer.length)
            throw RangeError("Illegal offset: 0 &lt;= "+offset+" (+"+4+") &lt;= "+this.buffer.length);
    }
    var value = 0;
    if (this.littleEndian) {
        value  = this.buffer[offset+2] &lt;&lt; 16;
        value |= this.buffer[offset+1] &lt;&lt;  8;
        value |= this.buffer[offset  ];
        value += this.buffer[offset+3] &lt;&lt; 24 &gt;&gt;&gt; 0;
    } else {
        value  = this.buffer[offset+1] &lt;&lt; 16;
        value |= this.buffer[offset+2] &lt;&lt;  8;
        value |= this.buffer[offset+3];
        value += this.buffer[offset  ] &lt;&lt; 24 &gt;&gt;&gt; 0;
    }
    value |= 0; // Cast to signed
    if (relative) this.offset += 4;
    return value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.index.prototype.readInt64" id="apidoc.element.bytebuffer.index.prototype.readInt64">
        function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>readInt64
        <span class="apidocSignatureSpan">(offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readInt64 = function (offset) {
    var relative = typeof offset === 'undefined';
    if (relative) offset = this.offset;
    if (!this.noAssert) {
        if (typeof offset !== 'number' || offset % 1 !== 0)
            throw TypeError("Illegal offset: "+offset+" (not an integer)");
        offset &gt;&gt;&gt;= 0;
        if (offset &lt; 0 || offset + 8 &gt; this.buffer.length)
            throw RangeError("Illegal offset: 0 &lt;= "+offset+" (+"+8+") &lt;= "+this.buffer.length);
    }
    var lo = 0,
        hi = 0;
    if (this.littleEndian) {
        lo  = this.buffer[offset+2] &lt;&lt; 16;
        lo |= this.buffer[offset+1] &lt;&lt;  8;
        lo |= this.buffer[offset  ];
        lo += this.buffer[offset+3] &lt;&lt; 24 &gt;&gt;&gt; 0;
        offset += 4;
        hi  = this.buffer[offset+2] &lt;&lt; 16;
        hi |= this.buffer[offset+1] &lt;&lt;  8;
        hi |= this.buffer[offset  ];
        hi += this.buffer[offset+3] &lt;&lt; 24 &gt;&gt;&gt; 0;
    } else {
        hi  = this.buffer[offset+1] &lt;&lt; 16;
        hi |= this.buffer[offset+2] &lt;&lt;  8;
        hi |= this.buffer[offset+3];
        hi += this.buffer[offset  ] &lt;&lt; 24 &gt;&gt;&gt; 0;
        offset += 4;
        lo  = this.buffer[offset+1] &lt;&lt; 16;
        lo |= this.buffer[offset+2] &lt;&lt;  8;
        lo |= this.buffer[offset+3];
        lo += this.buffer[offset  ] &lt;&lt; 24 &gt;&gt;&gt; 0;
    }
    var value = new Long(lo, hi, false);
    if (relative) this.offset += 8;
    return value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.index.prototype.readInt8" id="apidoc.element.bytebuffer.index.prototype.readInt8">
        function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>readInt8
        <span class="apidocSignatureSpan">(offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readInt8 = function (offset) {
    var relative = typeof offset === 'undefined';
    if (relative) offset = this.offset;
    if (!this.noAssert) {
        if (typeof offset !== 'number' || offset % 1 !== 0)
            throw TypeError("Illegal offset: "+offset+" (not an integer)");
        offset &gt;&gt;&gt;= 0;
        if (offset &lt; 0 || offset + 1 &gt; this.buffer.length)
            throw RangeError("Illegal offset: 0 &lt;= "+offset+" (+"+1+") &lt;= "+this.buffer.length);
    }
    var value = this.buffer[offset];
    if ((value &amp; 0x80) === 0x80) value = -(0xFF - value + 1); // Cast to signed
    if (relative) this.offset += 1;
    return value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.index.prototype.readLong" id="apidoc.element.bytebuffer.index.prototype.readLong">
        function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>readLong
        <span class="apidocSignatureSpan">(offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readLong = function (offset) {
    var relative = typeof offset === 'undefined';
    if (relative) offset = this.offset;
    if (!this.noAssert) {
        if (typeof offset !== 'number' || offset % 1 !== 0)
            throw TypeError("Illegal offset: "+offset+" (not an integer)");
        offset &gt;&gt;&gt;= 0;
        if (offset &lt; 0 || offset + 8 &gt; this.buffer.length)
            throw RangeError("Illegal offset: 0 &lt;= "+offset+" (+"+8+") &lt;= "+this.buffer.length);
    }
    var lo = 0,
        hi = 0;
    if (this.littleEndian) {
        lo  = this.buffer[offset+2] &lt;&lt; 16;
        lo |= this.buffer[offset+1] &lt;&lt;  8;
        lo |= this.buffer[offset  ];
        lo += this.buffer[offset+3] &lt;&lt; 24 &gt;&gt;&gt; 0;
        offset += 4;
        hi  = this.buffer[offset+2] &lt;&lt; 16;
        hi |= this.buffer[offset+1] &lt;&lt;  8;
        hi |= this.buffer[offset  ];
        hi += this.buffer[offset+3] &lt;&lt; 24 &gt;&gt;&gt; 0;
    } else {
        hi  = this.buffer[offset+1] &lt;&lt; 16;
        hi |= this.buffer[offset+2] &lt;&lt;  8;
        hi |= this.buffer[offset+3];
        hi += this.buffer[offset  ] &lt;&lt; 24 &gt;&gt;&gt; 0;
        offset += 4;
        lo  = this.buffer[offset+1] &lt;&lt; 16;
        lo |= this.buffer[offset+2] &lt;&lt;  8;
        lo |= this.buffer[offset+3];
        lo += this.buffer[offset  ] &lt;&lt; 24 &gt;&gt;&gt; 0;
    }
    var value = new Long(lo, hi, false);
    if (relative) this.offset += 8;
    return value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.index.prototype.readShort" id="apidoc.element.bytebuffer.index.prototype.readShort">
        function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>readShort
        <span class="apidocSignatureSpan">(offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readShort = function (offset) {
    var relative = typeof offset === 'undefined';
    if (relative) offset = this.offset;
    if (!this.noAssert) {
        if (typeof offset !== 'number' || offset % 1 !== 0)
            throw TypeError("Illegal offset: "+offset+" (not an integer)");
        offset &gt;&gt;&gt;= 0;
        if (offset &lt; 0 || offset + 2 &gt; this.buffer.length)
            throw RangeError("Illegal offset: 0 &lt;= "+offset+" (+"+2+") &lt;= "+this.buffer.length);
    }
    var value = 0;
    if (this.littleEndian) {
        value  = this.buffer[offset  ];
        value |= this.buffer[offset+1] &lt;&lt; 8;
    } else {
        value  = this.buffer[offset  ] &lt;&lt; 8;
        value |= this.buffer[offset+1];
    }
    if ((value &amp; 0x8000) === 0x8000) value = -(0xFFFF - value + 1); // Cast to signed
    if (relative) this.offset += 2;
    return value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.index.prototype.readString" id="apidoc.element.bytebuffer.index.prototype.readString">
        function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>readString
        <span class="apidocSignatureSpan">(length, metrics, offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readString = function (length, metrics, offset) {
    if (typeof metrics === 'number') {
        offset = metrics;
        metrics = undefined;
    }
    var relative = typeof offset === 'undefined';
    if (relative) offset = this.offset;
    if (typeof metrics === 'undefined') metrics = ByteBuffer.METRICS_CHARS;
    if (!this.noAssert) {
        if (typeof length !== 'number' || length % 1 !== 0)
            throw TypeError("Illegal length: "+length+" (not an integer)");
        length |= 0;
        if (typeof offset !== 'number' || offset % 1 !== 0)
            throw TypeError("Illegal offset: "+offset+" (not an integer)");
        offset &gt;&gt;&gt;= 0;
        if (offset &lt; 0 || offset + 0 &gt; this.buffer.length)
            throw RangeError("Illegal offset: 0 &lt;= "+offset+" (+"+0+") &lt;= "+this.buffer.length);
    }
    var i = 0,
        start = offset,
        temp,
        sd;
    if (metrics === ByteBuffer.METRICS_CHARS) { // The same for node and the browser
        sd = stringDestination();
        utfx.decodeUTF8(function() {
            return i &lt; length &amp;&amp; offset &lt; this.limit ? this.buffer[offset++] : null;
        }.bind(this), function(cp) {
            ++i; utfx.UTF8toUTF16(cp, sd);
        });
        if (i !== length)
            throw RangeError("Illegal range: Truncated data, "+i+" == "+length);
        if (relative) {
            this.offset = offset;
            return sd();
        } else {
            return {
                "string": sd(),
                "length": offset - start
            };
        }
    } else if (metrics === ByteBuffer.METRICS_BYTES) {
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset &gt;&gt;&gt;= 0;
            if (offset &lt; 0 || offset + length &gt; this.buffer.length)
                throw RangeError("Illegal offset: 0 &lt;= "+offset+" (+"+length+") &lt;= "+this.buffer.length);
        }
        temp = this.buffer.toString("utf8", offset, offset+length);
        if (relative) {
            this.offset += length;
            return temp;
        } else {
            return {
                'string': temp,
                'length': length
            };
        }
    } else
        throw TypeError("Unsupported metrics: "+metrics);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.index.prototype.readUInt16" id="apidoc.element.bytebuffer.index.prototype.readUInt16">
        function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>readUInt16
        <span class="apidocSignatureSpan">(offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readUInt16 = function (offset) {
    var relative = typeof offset === 'undefined';
    if (relative) offset = this.offset;
    if (!this.noAssert) {
        if (typeof offset !== 'number' || offset % 1 !== 0)
            throw TypeError("Illegal offset: "+offset+" (not an integer)");
        offset &gt;&gt;&gt;= 0;
        if (offset &lt; 0 || offset + 2 &gt; this.buffer.length)
            throw RangeError("Illegal offset: 0 &lt;= "+offset+" (+"+2+") &lt;= "+this.buffer.length);
    }
    var value = 0;
    if (this.littleEndian) {
        value  = this.buffer[offset  ];
        value |= this.buffer[offset+1] &lt;&lt; 8;
    } else {
        value  = this.buffer[offset  ] &lt;&lt; 8;
        value |= this.buffer[offset+1];
    }
    if (relative) this.offset += 2;
    return value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.index.prototype.readUInt32" id="apidoc.element.bytebuffer.index.prototype.readUInt32">
        function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>readUInt32
        <span class="apidocSignatureSpan">(offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readUInt32 = function (offset) {
    var relative = typeof offset === 'undefined';
    if (relative) offset = this.offset;
    if (!this.noAssert) {
        if (typeof offset !== 'number' || offset % 1 !== 0)
            throw TypeError("Illegal offset: "+offset+" (not an integer)");
        offset &gt;&gt;&gt;= 0;
        if (offset &lt; 0 || offset + 4 &gt; this.buffer.length)
            throw RangeError("Illegal offset: 0 &lt;= "+offset+" (+"+4+") &lt;= "+this.buffer.length);
    }
    var value = 0;
    if (this.littleEndian) {
        value  = this.buffer[offset+2] &lt;&lt; 16;
        value |= this.buffer[offset+1] &lt;&lt;  8;
        value |= this.buffer[offset  ];
        value += this.buffer[offset+3] &lt;&lt; 24 &gt;&gt;&gt; 0;
    } else {
        value  = this.buffer[offset+1] &lt;&lt; 16;
        value |= this.buffer[offset+2] &lt;&lt;  8;
        value |= this.buffer[offset+3];
        value += this.buffer[offset  ] &lt;&lt; 24 &gt;&gt;&gt; 0;
    }
    if (relative) this.offset += 4;
    return value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.index.prototype.readUInt64" id="apidoc.element.bytebuffer.index.prototype.readUInt64">
        function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>readUInt64
        <span class="apidocSignatureSpan">(offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readUInt64 = function (offset) {
    var relative = typeof offset === 'undefined';
    if (relative) offset = this.offset;
    if (!this.noAssert) {
        if (typeof offset !== 'number' || offset % 1 !== 0)
            throw TypeError("Illegal offset: "+offset+" (not an integer)");
        offset &gt;&gt;&gt;= 0;
        if (offset &lt; 0 || offset + 8 &gt; this.buffer.length)
            throw RangeError("Illegal offset: 0 &lt;= "+offset+" (+"+8+") &lt;= "+this.buffer.length);
    }
    var lo = 0,
        hi = 0;
    if (this.littleEndian) {
        lo  = this.buffer[offset+2] &lt;&lt; 16;
        lo |= this.buffer[offset+1] &lt;&lt;  8;
        lo |= this.buffer[offset  ];
        lo += this.buffer[offset+3] &lt;&lt; 24 &gt;&gt;&gt; 0;
        offset += 4;
        hi  = this.buffer[offset+2] &lt;&lt; 16;
        hi |= this.buffer[offset+1] &lt;&lt;  8;
        hi |= this.buffer[offset  ];
        hi += this.buffer[offset+3] &lt;&lt; 24 &gt;&gt;&gt; 0;
    } else {
        hi  = this.buffer[offset+1] &lt;&lt; 16;
        hi |= this.buffer[offset+2] &lt;&lt;  8;
        hi |= this.buffer[offset+3];
        hi += this.buffer[offset  ] &lt;&lt; 24 &gt;&gt;&gt; 0;
        offset += 4;
        lo  = this.buffer[offset+1] &lt;&lt; 16;
        lo |= this.buffer[offset+2] &lt;&lt;  8;
        lo |= this.buffer[offset+3];
        lo += this.buffer[offset  ] &lt;&lt; 24 &gt;&gt;&gt; 0;
    }
    var value = new Long(lo, hi, true);
    if (relative) this.offset += 8;
    return value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.index.prototype.readUInt8" id="apidoc.element.bytebuffer.index.prototype.readUInt8">
        function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>readUInt8
        <span class="apidocSignatureSpan">(offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readUInt8 = function (offset) {
    var relative = typeof offset === 'undefined';
    if (relative) offset = this.offset;
    if (!this.noAssert) {
        if (typeof offset !== 'number' || offset % 1 !== 0)
            throw TypeError("Illegal offset: "+offset+" (not an integer)");
        offset &gt;&gt;&gt;= 0;
        if (offset &lt; 0 || offset + 1 &gt; this.buffer.length)
            throw RangeError("Illegal offset: 0 &lt;= "+offset+" (+"+1+") &lt;= "+this.buffer.length);
    }
    var value = this.buffer[offset];
    if (relative) this.offset += 1;
    return value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.index.prototype.readUTF8String" id="apidoc.element.bytebuffer.index.prototype.readUTF8String">
        function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>readUTF8String
        <span class="apidocSignatureSpan">(length, metrics, offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readUTF8String = function (length, metrics, offset) {
    if (typeof metrics === 'number') {
        offset = metrics;
        metrics = undefined;
    }
    var relative = typeof offset === 'undefined';
    if (relative) offset = this.offset;
    if (typeof metrics === 'undefined') metrics = ByteBuffer.METRICS_CHARS;
    if (!this.noAssert) {
        if (typeof length !== 'number' || length % 1 !== 0)
            throw TypeError("Illegal length: "+length+" (not an integer)");
        length |= 0;
        if (typeof offset !== 'number' || offset % 1 !== 0)
            throw TypeError("Illegal offset: "+offset+" (not an integer)");
        offset &gt;&gt;&gt;= 0;
        if (offset &lt; 0 || offset + 0 &gt; this.buffer.length)
            throw RangeError("Illegal offset: 0 &lt;= "+offset+" (+"+0+") &lt;= "+this.buffer.length);
    }
    var i = 0,
        start = offset,
        temp,
        sd;
    if (metrics === ByteBuffer.METRICS_CHARS) { // The same for node and the browser
        sd = stringDestination();
        utfx.decodeUTF8(function() {
            return i &lt; length &amp;&amp; offset &lt; this.limit ? this.buffer[offset++] : null;
        }.bind(this), function(cp) {
            ++i; utfx.UTF8toUTF16(cp, sd);
        });
        if (i !== length)
            throw RangeError("Illegal range: Truncated data, "+i+" == "+length);
        if (relative) {
            this.offset = offset;
            return sd();
        } else {
            return {
                "string": sd(),
                "length": offset - start
            };
        }
    } else if (metrics === ByteBuffer.METRICS_BYTES) {
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset &gt;&gt;&gt;= 0;
            if (offset &lt; 0 || offset + length &gt; this.buffer.length)
                throw RangeError("Illegal offset: 0 &lt;= "+offset+" (+"+length+") &lt;= "+this.buffer.length);
        }
        temp = this.buffer.toString("utf8", offset, offset+length);
        if (relative) {
            this.offset += length;
            return temp;
        } else {
            return {
                'string': temp,
                'length': length
            };
        }
    } else
        throw TypeError("Unsupported metrics: "+metrics);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.index.prototype.readUint16" id="apidoc.element.bytebuffer.index.prototype.readUint16">
        function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>readUint16
        <span class="apidocSignatureSpan">(offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readUint16 = function (offset) {
    var relative = typeof offset === 'undefined';
    if (relative) offset = this.offset;
    if (!this.noAssert) {
        if (typeof offset !== 'number' || offset % 1 !== 0)
            throw TypeError("Illegal offset: "+offset+" (not an integer)");
        offset &gt;&gt;&gt;= 0;
        if (offset &lt; 0 || offset + 2 &gt; this.buffer.length)
            throw RangeError("Illegal offset: 0 &lt;= "+offset+" (+"+2+") &lt;= "+this.buffer.length);
    }
    var value = 0;
    if (this.littleEndian) {
        value  = this.buffer[offset  ];
        value |= this.buffer[offset+1] &lt;&lt; 8;
    } else {
        value  = this.buffer[offset  ] &lt;&lt; 8;
        value |= this.buffer[offset+1];
    }
    if (relative) this.offset += 2;
    return value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.index.prototype.readUint32" id="apidoc.element.bytebuffer.index.prototype.readUint32">
        function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>readUint32
        <span class="apidocSignatureSpan">(offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readUint32 = function (offset) {
    var relative = typeof offset === 'undefined';
    if (relative) offset = this.offset;
    if (!this.noAssert) {
        if (typeof offset !== 'number' || offset % 1 !== 0)
            throw TypeError("Illegal offset: "+offset+" (not an integer)");
        offset &gt;&gt;&gt;= 0;
        if (offset &lt; 0 || offset + 4 &gt; this.buffer.length)
            throw RangeError("Illegal offset: 0 &lt;= "+offset+" (+"+4+") &lt;= "+this.buffer.length);
    }
    var value = 0;
    if (this.littleEndian) {
        value  = this.buffer[offset+2] &lt;&lt; 16;
        value |= this.buffer[offset+1] &lt;&lt;  8;
        value |= this.buffer[offset  ];
        value += this.buffer[offset+3] &lt;&lt; 24 &gt;&gt;&gt; 0;
    } else {
        value  = this.buffer[offset+1] &lt;&lt; 16;
        value |= this.buffer[offset+2] &lt;&lt;  8;
        value |= this.buffer[offset+3];
        value += this.buffer[offset  ] &lt;&lt; 24 &gt;&gt;&gt; 0;
    }
    if (relative) this.offset += 4;
    return value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.index.prototype.readUint64" id="apidoc.element.bytebuffer.index.prototype.readUint64">
        function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>readUint64
        <span class="apidocSignatureSpan">(offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readUint64 = function (offset) {
    var relative = typeof offset === 'undefined';
    if (relative) offset = this.offset;
    if (!this.noAssert) {
        if (typeof offset !== 'number' || offset % 1 !== 0)
            throw TypeError("Illegal offset: "+offset+" (not an integer)");
        offset &gt;&gt;&gt;= 0;
        if (offset &lt; 0 || offset + 8 &gt; this.buffer.length)
            throw RangeError("Illegal offset: 0 &lt;= "+offset+" (+"+8+") &lt;= "+this.buffer.length);
    }
    var lo = 0,
        hi = 0;
    if (this.littleEndian) {
        lo  = this.buffer[offset+2] &lt;&lt; 16;
        lo |= this.buffer[offset+1] &lt;&lt;  8;
        lo |= this.buffer[offset  ];
        lo += this.buffer[offset+3] &lt;&lt; 24 &gt;&gt;&gt; 0;
        offset += 4;
        hi  = this.buffer[offset+2] &lt;&lt; 16;
        hi |= this.buffer[offset+1] &lt;&lt;  8;
        hi |= this.buffer[offset  ];
        hi += this.buffer[offset+3] &lt;&lt; 24 &gt;&gt;&gt; 0;
    } else {
        hi  = this.buffer[offset+1] &lt;&lt; 16;
        hi |= this.buffer[offset+2] &lt;&lt;  8;
        hi |= this.buffer[offset+3];
        hi += this.buffer[offset  ] &lt;&lt; 24 &gt;&gt;&gt; 0;
        offset += 4;
        lo  = this.buffer[offset+1] &lt;&lt; 16;
        lo |= this.buffer[offset+2] &lt;&lt;  8;
        lo |= this.buffer[offset+3];
        lo += this.buffer[offset  ] &lt;&lt; 24 &gt;&gt;&gt; 0;
    }
    var value = new Long(lo, hi, true);
    if (relative) this.offset += 8;
    return value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.index.prototype.readUint8" id="apidoc.element.bytebuffer.index.prototype.readUint8">
        function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>readUint8
        <span class="apidocSignatureSpan">(offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readUint8 = function (offset) {
    var relative = typeof offset === 'undefined';
    if (relative) offset = this.offset;
    if (!this.noAssert) {
        if (typeof offset !== 'number' || offset % 1 !== 0)
            throw TypeError("Illegal offset: "+offset+" (not an integer)");
        offset &gt;&gt;&gt;= 0;
        if (offset &lt; 0 || offset + 1 &gt; this.buffer.length)
            throw RangeError("Illegal offset: 0 &lt;= "+offset+" (+"+1+") &lt;= "+this.buffer.length);
    }
    var value = this.buffer[offset];
    if (relative) this.offset += 1;
    return value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.index.prototype.readVString" id="apidoc.element.bytebuffer.index.prototype.readVString">
        function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>readVString
        <span class="apidocSignatureSpan">(offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readVString = function (offset) {
    var relative = typeof offset === 'undefined';
    if (relative) offset = this.offset;
    if (!this.noAssert) {
        if (typeof offset !== 'number' || offset % 1 !== 0)
            throw TypeError("Illegal offset: "+offset+" (not an integer)");
        offset &gt;&gt;&gt;= 0;
        if (offset &lt; 0 || offset + 1 &gt; this.buffer.length)
            throw RangeError("Illegal offset: 0 &lt;= "+offset+" (+"+1+") &lt;= "+this.buffer.length);
    }
    var start = offset;
    var len = this.readVarint32(offset);
    var str = this.readUTF8String(len['value'], ByteBuffer.METRICS_BYTES, offset += len['length']);
    offset += str['length'];
    if (relative) {
        this.offset = offset;
        return str['string'];
    } else {
        return {
            'string': str['string'],
            'length': offset - start
        };
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.index.prototype.readVarint32" id="apidoc.element.bytebuffer.index.prototype.readVarint32">
        function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>readVarint32
        <span class="apidocSignatureSpan">(offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readVarint32 = function (offset) {
    var relative = typeof offset === 'undefined';
    if (relative) offset = this.offset;
    if (!this.noAssert) {
        if (typeof offset !== 'number' || offset % 1 !== 0)
            throw TypeError("Illegal offset: "+offset+" (not an integer)");
        offset &gt;&gt;&gt;= 0;
        if (offset &lt; 0 || offset + 1 &gt; this.buffer.length)
            throw RangeError("Illegal offset: 0 &lt;= "+offset+" (+"+1+") &lt;= "+this.buffer.length);
    }
    var c = 0,
        value = 0 &gt;&gt;&gt; 0,
        b;
    do {
        if (!this.noAssert &amp;&amp; offset &gt; this.limit) {
            var err = Error("Truncated");
            err['truncated'] = true;
            throw err;
        }
        b = this.buffer[offset++];
        if (c &lt; 5)
            value |= (b &amp; 0x7f) &lt;&lt; (7*c);
        ++c;
    } while ((b &amp; 0x80) !== 0);
    value |= 0;
    if (relative) {
        this.offset = offset;
        return value;
    }
    return {
        "value": value,
        "length": c
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.index.prototype.readVarint32ZigZag" id="apidoc.element.bytebuffer.index.prototype.readVarint32ZigZag">
        function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>readVarint32ZigZag
        <span class="apidocSignatureSpan">(offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readVarint32ZigZag = function (offset) {
    var val = this.readVarint32(offset);
    if (typeof val === 'object')
        val["value"] = ByteBuffer.zigZagDecode32(val["value"]);
    else
        val = ByteBuffer.zigZagDecode32(val);
    return val;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.index.prototype.readVarint64" id="apidoc.element.bytebuffer.index.prototype.readVarint64">
        function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>readVarint64
        <span class="apidocSignatureSpan">(offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readVarint64 = function (offset) {
    var relative = typeof offset === 'undefined';
    if (relative) offset = this.offset;
    if (!this.noAssert) {
        if (typeof offset !== 'number' || offset % 1 !== 0)
            throw TypeError("Illegal offset: "+offset+" (not an integer)");
        offset &gt;&gt;&gt;= 0;
        if (offset &lt; 0 || offset + 1 &gt; this.buffer.length)
            throw RangeError("Illegal offset: 0 &lt;= "+offset+" (+"+1+") &lt;= "+this.buffer.length);
    }
    // ref: src/google/protobuf/io/coded_stream.cc
    var start = offset,
        part0 = 0,
        part1 = 0,
        part2 = 0,
        b  = 0;
    b = this.buffer[offset++]; part0  = (b &amp; 0x7F)      ; if ( b &amp; 0x80                                                   ) {
    b = this.buffer[offset++]; part0 |= (b &amp; 0x7F) &lt;&lt;  7; if ((b &amp; 0x80) || (this.noAssert &amp;&amp; typeof b === 'undefined')) {
    b = this.buffer[offset++]; part0 |= (b &amp; 0x7F) &lt;&lt; 14; if ((b &amp; 0x80) || (this.noAssert &amp;&amp; typeof b === 'undefined')) {
    b = this.buffer[offset++]; part0 |= (b &amp; 0x7F) &lt;&lt; 21; if ((b &amp; 0x80) || (this.noAssert &amp;&amp; typeof b === 'undefined')) {
    b = this.buffer[offset++]; part1  = (b &amp; 0x7F)      ; if ((b &amp; 0x80) || (this.noAssert &amp;&amp; typeof b === 'undefined')) {
    b = this.buffer[offset++]; part1 |= (b &amp; 0x7F) &lt;&lt;  7; if ((b &amp; 0x80) || (this.noAssert &amp;&amp; typeof b === 'undefined')) {
    b = this.buffer[offset++]; part1 |= (b &amp; 0x7F) &lt;&lt; 14; if ((b &amp; 0x80) || (this.noAssert &amp;&amp; typeof b === 'undefined')) {
    b = this.buffer[offset++]; part1 |= (b &amp; 0x7F) &lt;&lt; 21; if ((b &amp; 0x80) || (this.noAssert &amp;&amp; typeof b === 'undefined')) {
    b = this.buffer[offset++]; part2  = (b &amp; 0x7F)      ; if ((b &amp; 0x80) || (this.noAssert &amp;&amp; typeof b === 'undefined')) {
    b = this.buffer[offset++]; part2 |= (b &amp; 0x7F) &lt;&lt;  7; if ((b &amp; 0x80) || (this.noAssert &amp;&amp; typeof b === 'undefined')) {
    throw Error("Buffer overrun"); }}}}}}}}}}
    var value = Long.fromBits(part0 | (part1 &lt;&lt; 28), (part1 &gt;&gt;&gt; 4) | (part2) &lt;&lt; 24, false);
    if (relative) {
        this.offset = offset;
        return value;
    } else {
        return {
            'value': value,
            'length': offset-start
        };
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.index.prototype.readVarint64ZigZag" id="apidoc.element.bytebuffer.index.prototype.readVarint64ZigZag">
        function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>readVarint64ZigZag
        <span class="apidocSignatureSpan">(offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readVarint64ZigZag = function (offset) {
    var val = this.readVarint64(offset);
    if (val &amp;&amp; val['value'] instanceof Long)
        val["value"] = ByteBuffer.zigZagDecode64(val["value"]);
    else
        val = ByteBuffer.zigZagDecode64(val);
    return val;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.index.prototype.remaining" id="apidoc.element.bytebuffer.index.prototype.remaining">
        function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>remaining
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">remaining = function () {
    return this.limit - this.offset;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.index.prototype.reset" id="apidoc.element.bytebuffer.index.prototype.reset">
        function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>reset
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">reset = function () {
    if (this.markedOffset &gt;= 0) {
        this.offset = this.markedOffset;
        this.markedOffset = -1;
    } else {
        this.offset = 0;
    }
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.index.prototype.resize" id="apidoc.element.bytebuffer.index.prototype.resize">
        function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>resize
        <span class="apidocSignatureSpan">(capacity)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">resize = function (capacity) {
    if (!this.noAssert) {
        if (typeof capacity !== 'number' || capacity % 1 !== 0)
            throw TypeError("Illegal capacity: "+capacity+" (not an integer)");
        capacity |= 0;
        if (capacity &lt; 0)
            throw RangeError("Illegal capacity: 0 &lt;= "+capacity);
    }
    if (this.buffer.length &lt; capacity) {
        var buffer = new Buffer(capacity);
        this.buffer.copy(buffer);
        this.buffer = buffer;
    }
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.index.prototype.reverse" id="apidoc.element.bytebuffer.index.prototype.reverse">
        function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>reverse
        <span class="apidocSignatureSpan">(begin, end)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">reverse = function (begin, end) {
    if (typeof begin === 'undefined') begin = this.offset;
    if (typeof end === 'undefined') end = this.limit;
    if (!this.noAssert) {
        if (typeof begin !== 'number' || begin % 1 !== 0)
            throw TypeError("Illegal begin: Not an integer");
        begin &gt;&gt;&gt;= 0;
        if (typeof end !== 'number' || end % 1 !== 0)
            throw TypeError("Illegal end: Not an integer");
        end &gt;&gt;&gt;= 0;
        if (begin &lt; 0 || begin &gt; end || end &gt; this.buffer.length)
            throw RangeError("Illegal range: 0 &lt;= "+begin+" &lt;= "+end+" &lt;= "+this.buffer.length);
    }
    if (begin === end)
        return this; // Nothing to reverse
    Array.prototype.reverse.call(this.buffer.slice(begin, end));
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.index.prototype.skip" id="apidoc.element.bytebuffer.index.prototype.skip">
        function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>skip
        <span class="apidocSignatureSpan">(length)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">skip = function (length) {
    if (!this.noAssert) {
        if (typeof length !== 'number' || length % 1 !== 0)
            throw TypeError("Illegal length: "+length+" (not an integer)");
        length |= 0;
    }
    var offset = this.offset + length;
    if (!this.noAssert) {
        if (offset &lt; 0 || offset &gt; this.buffer.length)
            throw RangeError("Illegal length: 0 &lt;= "+this.offset+" + "+length+" &lt;= "+this.buffer.length);
    }
    this.offset = offset;
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.index.prototype.slice" id="apidoc.element.bytebuffer.index.prototype.slice">
        function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>slice
        <span class="apidocSignatureSpan">(begin, end)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">slice = function (begin, end) {
    if (typeof begin === 'undefined') begin = this.offset;
    if (typeof end === 'undefined') end = this.limit;
    if (!this.noAssert) {
        if (typeof begin !== 'number' || begin % 1 !== 0)
            throw TypeError("Illegal begin: Not an integer");
        begin &gt;&gt;&gt;= 0;
        if (typeof end !== 'number' || end % 1 !== 0)
            throw TypeError("Illegal end: Not an integer");
        end &gt;&gt;&gt;= 0;
        if (begin &lt; 0 || begin &gt; end || end &gt; this.buffer.length)
            throw RangeError("Illegal range: 0 &lt;= "+begin+" &lt;= "+end+" &lt;= "+this.buffer.length);
    }
    var bb = this.clone();
    bb.offset = begin;
    bb.limit = end;
    return bb;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.index.prototype.toArrayBuffer" id="apidoc.element.bytebuffer.index.prototype.toArrayBuffer">
        function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>toArrayBuffer
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toArrayBuffer = function () {
    var offset = this.offset,
        limit = this.limit;
    if (!this.noAssert) {
        if (typeof offset !== 'number' || offset % 1 !== 0)
            throw TypeError("Illegal offset: Not an integer");
        offset &gt;&gt;&gt;= 0;
        if (typeof limit !== 'number' || limit % 1 !== 0)
            throw TypeError("Illegal limit: Not an integer");
        limit &gt;&gt;&gt;= 0;
        if (offset &lt; 0 || offset &gt; limit || limit &gt; this.buffer.length)
            throw RangeError("Illegal range: 0 &lt;= "+offset+" &lt;= "+limit+" &lt;= "+this.buffer.length);
    }
    var ab = new ArrayBuffer(limit - offset);
    if (memcpy) { // Fast
        memcpy(ab, 0, this.buffer, offset, limit);
    } else { // Slow
        var dst = new Uint8Array(ab);
        for (var i=offset; i&lt;limit; ++i)
            dst[i-offset] = this.buffer[i];
    }
    return ab;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.index.prototype.toBase64" id="apidoc.element.bytebuffer.index.prototype.toBase64">
        function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>toBase64
        <span class="apidocSignatureSpan">(begin, end)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toBase64 = function (begin, end) {
    if (typeof begin === 'undefined')
        begin = this.offset;
    if (typeof end === 'undefined')
        end = this.limit;
    begin = begin | 0; end = end | 0;
    if (begin &lt; 0 || end &gt; this.capacity || begin &gt; end)
        throw RangeError("begin, end");
    return this.buffer.toString("base64", begin, end);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.index.prototype.toBinary" id="apidoc.element.bytebuffer.index.prototype.toBinary">
        function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>toBinary
        <span class="apidocSignatureSpan">(begin, end)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toBinary = function (begin, end) {
    if (typeof begin === 'undefined')
        begin = this.offset;
    if (typeof end === 'undefined')
        end = this.limit;
    begin |= 0; end |= 0;
    if (begin &lt; 0 || end &gt; this.capacity() || begin &gt; end)
        throw RangeError("begin, end");
    return this.buffer.toString("binary", begin, end);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.index.prototype.toBuffer" id="apidoc.element.bytebuffer.index.prototype.toBuffer">
        function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>toBuffer
        <span class="apidocSignatureSpan">(forceCopy)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toBuffer = function (forceCopy) {
    var offset = this.offset,
        limit = this.limit;
    if (!this.noAssert) {
        if (typeof offset !== 'number' || offset % 1 !== 0)
            throw TypeError("Illegal offset: Not an integer");
        offset &gt;&gt;&gt;= 0;
        if (typeof limit !== 'number' || limit % 1 !== 0)
            throw TypeError("Illegal limit: Not an integer");
        limit &gt;&gt;&gt;= 0;
        if (offset &lt; 0 || offset &gt; limit || limit &gt; this.buffer.length)
            throw RangeError("Illegal range: 0 &lt;= "+offset+" &lt;= "+limit+" &lt;= "+this.buffer.length);
    }
    if (forceCopy) {
        var buffer = new Buffer(limit - offset);
        this.buffer.copy(buffer, 0, offset, limit);
        return buffer;
    } else {
        if (offset === 0 &amp;&amp; limit === this.buffer.length)
            return this.buffer;
        else
            return this.buffer.slice(offset, limit);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.index.prototype.toDebug" id="apidoc.element.bytebuffer.index.prototype.toDebug">
        function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>toDebug
        <span class="apidocSignatureSpan">(columns)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toDebug = function (columns) {
    var i = -1,
        k = this.buffer.length,
        b,
        hex = "",
        asc = "",
        out = "";
    while (i&lt;k) {
        if (i !== -1) {
            b = this.buffer[i];
            if (b &lt; 0x10) hex += "0"+b.toString(16).toUpperCase();
            else hex += b.toString(16).toUpperCase();
            if (columns)
                asc += b &gt; 32 &amp;&amp; b &lt; 127 ? String.fromCharCode(b) : '.';
        }
        ++i;
        if (columns) {
            if (i &gt; 0 &amp;&amp; i % 16 === 0 &amp;&amp; i !== k) {
                while (hex.length &lt; 3*16+3) hex += " ";
                out += hex+asc+"\n";
                hex = asc = "";
            }
        }
        if (i === this.offset &amp;&amp; i === this.limit)
            hex += i === this.markedOffset ? "!" : "|";
        else if (i === this.offset)
            hex += i === this.markedOffset ? "[" : "&lt;";
        else if (i === this.limit)
            hex += i === this.markedOffset ? "]" : "&gt;";
        else
            hex += i === this.markedOffset ? "'" : (columns || (i !== 0 &amp;&amp; i !== k) ? " " : "");
    }
    if (columns &amp;&amp; hex !== " ") {
        while (hex.length &lt; 3*16+3)
            hex += " ";
        out += hex + asc + "\n";
    }
    return columns ? out : hex;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.index.prototype.toHex" id="apidoc.element.bytebuffer.index.prototype.toHex">
        function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>toHex
        <span class="apidocSignatureSpan">(begin, end)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toHex = function (begin, end) {
    begin = typeof begin === 'undefined' ? this.offset : begin;
    end = typeof end === 'undefined' ? this.limit : end;
    if (!this.noAssert) {
        if (typeof begin !== 'number' || begin % 1 !== 0)
            throw TypeError("Illegal begin: Not an integer");
        begin &gt;&gt;&gt;= 0;
        if (typeof end !== 'number' || end % 1 !== 0)
            throw TypeError("Illegal end: Not an integer");
        end &gt;&gt;&gt;= 0;
        if (begin &lt; 0 || begin &gt; end || end &gt; this.buffer.length)
            throw RangeError("Illegal range: 0 &lt;= "+begin+" &lt;= "+end+" &lt;= "+this.buffer.length);
    }
    return this.buffer.toString("hex", begin, end);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.index.prototype.toString" id="apidoc.element.bytebuffer.index.prototype.toString">
        function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>toString
        <span class="apidocSignatureSpan">(encoding, begin, end)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toString = function (encoding, begin, end) {
    if (typeof encoding === 'undefined')
        return "ByteBufferNB(offset="+this.offset+",markedOffset="+this.markedOffset+",limit="+this.limit+",capacity="+this.capacity
()+")";
    if (typeof encoding === 'number')
        encoding = "utf8",
        begin = encoding,
        end = begin;
    switch (encoding) {
        case "utf8":
            return this.toUTF8(begin, end);
        case "base64":
            return this.toBase64(begin, end);
        case "hex":
            return this.toHex(begin, end);
        case "binary":
            return this.toBinary(begin, end);
        case "debug":
            return this.toDebug();
        case "columns":
            return this.toColumns();
        default:
            throw Error("Unsupported encoding: "+encoding);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.index.prototype.toUTF8" id="apidoc.element.bytebuffer.index.prototype.toUTF8">
        function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>toUTF8
        <span class="apidocSignatureSpan">(begin, end)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toUTF8 = function (begin, end) {
    if (typeof begin === 'undefined') begin = this.offset;
    if (typeof end === 'undefined') end = this.limit;
    if (!this.noAssert) {
        if (typeof begin !== 'number' || begin % 1 !== 0)
            throw TypeError("Illegal begin: Not an integer");
        begin &gt;&gt;&gt;= 0;
        if (typeof end !== 'number' || end % 1 !== 0)
            throw TypeError("Illegal end: Not an integer");
        end &gt;&gt;&gt;= 0;
        if (begin &lt; 0 || begin &gt; end || end &gt; this.buffer.length)
            throw RangeError("Illegal range: 0 &lt;= "+begin+" &lt;= "+end+" &lt;= "+this.buffer.length);
    }
    return this.buffer.toString("utf8", begin, end);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.index.prototype.writeBitSet" id="apidoc.element.bytebuffer.index.prototype.writeBitSet">
        function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>writeBitSet
        <span class="apidocSignatureSpan">(value, offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeBitSet = function (value, offset) {
  var relative = typeof offset === 'undefined';
  if (relative) offset = this.offset;
  if (!this.noAssert) {
    if (!(value instanceof Array))
      throw TypeError("Illegal BitSet: Not an array");
    if (typeof offset !== 'number' || offset % 1 !== 0)
        throw TypeError("Illegal offset: "+offset+" (not an integer)");
    offset &gt;&gt;&gt;= 0;
    if (offset &lt; 0 || offset + 0 &gt; this.buffer.length)
        throw RangeError("Illegal offset: 0 &lt;= "+offset+" (+"+0+") &lt;= "+this.buffer.length);
  }

  var start = offset,
      bits = value.length,
      bytes = (bits &gt;&gt; 3),
      bit = 0,
      k;

  offset += this.writeVarint32(bits,offset);

  while(bytes--) {
    k = (!!value[bit++] &amp; 1) |
        ((!!value[bit++] &amp; 1) &lt;&lt; 1) |
        ((!!value[bit++] &amp; 1) &lt;&lt; 2) |
        ((!!value[bit++] &amp; 1) &lt;&lt; 3) |
        ((!!value[bit++] &amp; 1) &lt;&lt; 4) |
        ((!!value[bit++] &amp; 1) &lt;&lt; 5) |
        ((!!value[bit++] &amp; 1) &lt;&lt; 6) |
        ((!!value[bit++] &amp; 1) &lt;&lt; 7);
    this.writeByte(k,offset++);
  }

  if(bit &lt; bits) {
    var m = 0; k = 0;
    while(bit &lt; bits) k = k | ((!!value[bit++] &amp; 1) &lt;&lt; (m++));
    this.writeByte(k,offset++);
  }

  if (relative) {
    this.offset = offset;
    return this;
  }
  return offset - start;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.index.prototype.writeByte" id="apidoc.element.bytebuffer.index.prototype.writeByte">
        function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>writeByte
        <span class="apidocSignatureSpan">(value, offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeByte = function (value, offset) {
    var relative = typeof offset === 'undefined';
    if (relative) offset = this.offset;
    if (!this.noAssert) {
        if (typeof value !== 'number' || value % 1 !== 0)
            throw TypeError("Illegal value: "+value+" (not an integer)");
        value |= 0;
        if (typeof offset !== 'number' || offset % 1 !== 0)
            throw TypeError("Illegal offset: "+offset+" (not an integer)");
        offset &gt;&gt;&gt;= 0;
        if (offset &lt; 0 || offset + 0 &gt; this.buffer.length)
            throw RangeError("Illegal offset: 0 &lt;= "+offset+" (+"+0+") &lt;= "+this.buffer.length);
    }
    offset += 1;
    var capacity0 = this.buffer.length;
    if (offset &gt; capacity0)
        this.resize((capacity0 *= 2) &gt; offset ? capacity0 : offset);
    offset -= 1;
    this.buffer[offset] = value;
    if (relative) this.offset += 1;
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.index.prototype.writeCString" id="apidoc.element.bytebuffer.index.prototype.writeCString">
        function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>writeCString
        <span class="apidocSignatureSpan">(str, offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeCString = function (str, offset) {
    var relative = typeof offset === 'undefined';
    if (relative) offset = this.offset;
    var i,
        k = str.length;
    if (!this.noAssert) {
        if (typeof str !== 'string')
            throw TypeError("Illegal str: Not a string");
        for (i=0; i&lt;k; ++i) {
            if (str.charCodeAt(i) === 0)
                throw RangeError("Illegal str: Contains NULL-characters");
        }
        if (typeof offset !== 'number' || offset % 1 !== 0)
            throw TypeError("Illegal offset: "+offset+" (not an integer)");
        offset &gt;&gt;&gt;= 0;
        if (offset &lt; 0 || offset + 0 &gt; this.buffer.length)
            throw RangeError("Illegal offset: 0 &lt;= "+offset+" (+"+0+") &lt;= "+this.buffer.length);
    }
    // UTF8 strings do not contain zero bytes in between except for the zero character, so:
    k = Buffer.byteLength(str, "utf8");
    offset += k+1;
    var capacity12 = this.buffer.length;
    if (offset &gt; capacity12)
        this.resize((capacity12 *= 2) &gt; offset ? capacity12 : offset);
    offset -= k+1;
    offset += this.buffer.write(str, offset, k, "utf8");
    this.buffer[offset++] = 0;
    if (relative) {
        this.offset = offset;
        return this;
    }
    return k;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.index.prototype.writeDouble" id="apidoc.element.bytebuffer.index.prototype.writeDouble">
        function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>writeDouble
        <span class="apidocSignatureSpan">(value, offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeDouble = function (value, offset) {
    var relative = typeof offset === 'undefined';
    if (relative) offset = this.offset;
    if (!this.noAssert) {
        if (typeof value !== 'number')
            throw TypeError("Illegal value: "+value+" (not a number)");
        if (typeof offset !== 'number' || offset % 1 !== 0)
            throw TypeError("Illegal offset: "+offset+" (not an integer)");
        offset &gt;&gt;&gt;= 0;
        if (offset &lt; 0 || offset + 0 &gt; this.buffer.length)
            throw RangeError("Illegal offset: 0 &lt;= "+offset+" (+"+0+") &lt;= "+this.buffer.length);
    }
    offset += 8;
    var capacity9 = this.buffer.length;
    if (offset &gt; capacity9)
        this.resize((capacity9 *= 2) &gt; offset ? capacity9 : offset);
    offset -= 8;
    this.littleEndian
        ? this.buffer.writeDoubleLE(value, offset, true)
        : this.buffer.writeDoubleBE(value, offset, true);
    if (relative) this.offset += 8;
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.index.prototype.writeFloat" id="apidoc.element.bytebuffer.index.prototype.writeFloat">
        function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>writeFloat
        <span class="apidocSignatureSpan">(value, offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeFloat = function (value, offset) {
    var relative = typeof offset === 'undefined';
    if (relative) offset = this.offset;
    if (!this.noAssert) {
        if (typeof value !== 'number')
            throw TypeError("Illegal value: "+value+" (not a number)");
        if (typeof offset !== 'number' || offset % 1 !== 0)
            throw TypeError("Illegal offset: "+offset+" (not an integer)");
        offset &gt;&gt;&gt;= 0;
        if (offset &lt; 0 || offset + 0 &gt; this.buffer.length)
            throw RangeError("Illegal offset: 0 &lt;= "+offset+" (+"+0+") &lt;= "+this.buffer.length);
    }
    offset += 4;
    var capacity8 = this.buffer.length;
    if (offset &gt; capacity8)
        this.resize((capacity8 *= 2) &gt; offset ? capacity8 : offset);
    offset -= 4;
    this.littleEndian
        ? this.buffer.writeFloatLE(value, offset, true)
        : this.buffer.writeFloatBE(value, offset, true);
    if (relative) this.offset += 4;
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.index.prototype.writeFloat32" id="apidoc.element.bytebuffer.index.prototype.writeFloat32">
        function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>writeFloat32
        <span class="apidocSignatureSpan">(value, offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeFloat32 = function (value, offset) {
    var relative = typeof offset === 'undefined';
    if (relative) offset = this.offset;
    if (!this.noAssert) {
        if (typeof value !== 'number')
            throw TypeError("Illegal value: "+value+" (not a number)");
        if (typeof offset !== 'number' || offset % 1 !== 0)
            throw TypeError("Illegal offset: "+offset+" (not an integer)");
        offset &gt;&gt;&gt;= 0;
        if (offset &lt; 0 || offset + 0 &gt; this.buffer.length)
            throw RangeError("Illegal offset: 0 &lt;= "+offset+" (+"+0+") &lt;= "+this.buffer.length);
    }
    offset += 4;
    var capacity8 = this.buffer.length;
    if (offset &gt; capacity8)
        this.resize((capacity8 *= 2) &gt; offset ? capacity8 : offset);
    offset -= 4;
    this.littleEndian
        ? this.buffer.writeFloatLE(value, offset, true)
        : this.buffer.writeFloatBE(value, offset, true);
    if (relative) this.offset += 4;
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.index.prototype.writeFloat64" id="apidoc.element.bytebuffer.index.prototype.writeFloat64">
        function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>writeFloat64
        <span class="apidocSignatureSpan">(value, offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeFloat64 = function (value, offset) {
    var relative = typeof offset === 'undefined';
    if (relative) offset = this.offset;
    if (!this.noAssert) {
        if (typeof value !== 'number')
            throw TypeError("Illegal value: "+value+" (not a number)");
        if (typeof offset !== 'number' || offset % 1 !== 0)
            throw TypeError("Illegal offset: "+offset+" (not an integer)");
        offset &gt;&gt;&gt;= 0;
        if (offset &lt; 0 || offset + 0 &gt; this.buffer.length)
            throw RangeError("Illegal offset: 0 &lt;= "+offset+" (+"+0+") &lt;= "+this.buffer.length);
    }
    offset += 8;
    var capacity9 = this.buffer.length;
    if (offset &gt; capacity9)
        this.resize((capacity9 *= 2) &gt; offset ? capacity9 : offset);
    offset -= 8;
    this.littleEndian
        ? this.buffer.writeDoubleLE(value, offset, true)
        : this.buffer.writeDoubleBE(value, offset, true);
    if (relative) this.offset += 8;
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.index.prototype.writeIString" id="apidoc.element.bytebuffer.index.prototype.writeIString">
        function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>writeIString
        <span class="apidocSignatureSpan">(str, offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeIString = function (str, offset) {
    var relative = typeof offset === 'undefined';
    if (relative) offset = this.offset;
    if (!this.noAssert) {
        if (typeof str !== 'string')
            throw TypeError("Illegal str: Not a string");
        if (typeof offset !== 'number' || offset % 1 !== 0)
            throw TypeError("Illegal offset: "+offset+" (not an integer)");
        offset &gt;&gt;&gt;= 0;
        if (offset &lt; 0 || offset + 0 &gt; this.buffer.length)
            throw RangeError("Illegal offset: 0 &lt;= "+offset+" (+"+0+") &lt;= "+this.buffer.length);
    }
    var start = offset,
        k;
    k = Buffer.byteLength(str, "utf8");
    offset += 4+k;
    var capacity13 = this.buffer.length;
    if (offset &gt; capacity13)
        this.resize((capacity13 *= 2) &gt; offset ? capacity13 : offset);
    offset -= 4+k;
    if (this.littleEndian) {
        this.buffer[offset+3] = (k &gt;&gt;&gt; 24) &amp; 0xFF;
        this.buffer[offset+2] = (k &gt;&gt;&gt; 16) &amp; 0xFF;
        this.buffer[offset+1] = (k &gt;&gt;&gt;  8) &amp; 0xFF;
        this.buffer[offset  ] =  k         &amp; 0xFF;
    } else {
        this.buffer[offset  ] = (k &gt;&gt;&gt; 24) &amp; 0xFF;
        this.buffer[offset+1] = (k &gt;&gt;&gt; 16) &amp; 0xFF;
        this.buffer[offset+2] = (k &gt;&gt;&gt;  8) &amp; 0xFF;
        this.buffer[offset+3] =  k         &amp; 0xFF;
    }
    offset += 4;
    offset += this.buffer.write(str, offset, k, "utf8");
    if (relative) {
        this.offset = offset;
        return this;
    }
    return offset - start;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
The library is compatible with CommonJS and AMD loaders and is exposed globally as `dcodeIO.ByteBuffer` if neither is
available.

```javascript
var ByteBuffer = require("bytebuffer");

var bb = new ByteBuffer()
            .<span class="apidocCodeKeywordSpan">writeIString</span>("Hello world!")
            .flip();
console.log(bb.readIString()+" from bytebuffer.js");
```

In the browser, 64 bit integer support is optional and present only if [Long.js](https://github.com/dcodeIO/long.js) has
been loaded prior to bytebuffer.js.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.index.prototype.writeInt" id="apidoc.element.bytebuffer.index.prototype.writeInt">
        function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>writeInt
        <span class="apidocSignatureSpan">(value, offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeInt = function (value, offset) {
    var relative = typeof offset === 'undefined';
    if (relative) offset = this.offset;
    if (!this.noAssert) {
        if (typeof value !== 'number' || value % 1 !== 0)
            throw TypeError("Illegal value: "+value+" (not an integer)");
        value |= 0;
        if (typeof offset !== 'number' || offset % 1 !== 0)
            throw TypeError("Illegal offset: "+offset+" (not an integer)");
        offset &gt;&gt;&gt;= 0;
        if (offset &lt; 0 || offset + 0 &gt; this.buffer.length)
            throw RangeError("Illegal offset: 0 &lt;= "+offset+" (+"+0+") &lt;= "+this.buffer.length);
    }
    offset += 4;
    var capacity4 = this.buffer.length;
    if (offset &gt; capacity4)
        this.resize((capacity4 *= 2) &gt; offset ? capacity4 : offset);
    offset -= 4;
    if (this.littleEndian) {
        this.buffer[offset+3] = (value &gt;&gt;&gt; 24) &amp; 0xFF;
        this.buffer[offset+2] = (value &gt;&gt;&gt; 16) &amp; 0xFF;
        this.buffer[offset+1] = (value &gt;&gt;&gt;  8) &amp; 0xFF;
        this.buffer[offset  ] =  value         &amp; 0xFF;
    } else {
        this.buffer[offset  ] = (value &gt;&gt;&gt; 24) &amp; 0xFF;
        this.buffer[offset+1] = (value &gt;&gt;&gt; 16) &amp; 0xFF;
        this.buffer[offset+2] = (value &gt;&gt;&gt;  8) &amp; 0xFF;
        this.buffer[offset+3] =  value         &amp; 0xFF;
    }
    if (relative) this.offset += 4;
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.index.prototype.writeInt16" id="apidoc.element.bytebuffer.index.prototype.writeInt16">
        function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>writeInt16
        <span class="apidocSignatureSpan">(value, offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeInt16 = function (value, offset) {
    var relative = typeof offset === 'undefined';
    if (relative) offset = this.offset;
    if (!this.noAssert) {
        if (typeof value !== 'number' || value % 1 !== 0)
            throw TypeError("Illegal value: "+value+" (not an integer)");
        value |= 0;
        if (typeof offset !== 'number' || offset % 1 !== 0)
            throw TypeError("Illegal offset: "+offset+" (not an integer)");
        offset &gt;&gt;&gt;= 0;
        if (offset &lt; 0 || offset + 0 &gt; this.buffer.length)
            throw RangeError("Illegal offset: 0 &lt;= "+offset+" (+"+0+") &lt;= "+this.buffer.length);
    }
    offset += 2;
    var capacity2 = this.buffer.length;
    if (offset &gt; capacity2)
        this.resize((capacity2 *= 2) &gt; offset ? capacity2 : offset);
    offset -= 2;
    if (this.littleEndian) {
        this.buffer[offset+1] = (value &amp; 0xFF00) &gt;&gt;&gt; 8;
        this.buffer[offset  ] =  value &amp; 0x00FF;
    } else {
        this.buffer[offset]   = (value &amp; 0xFF00) &gt;&gt;&gt; 8;
        this.buffer[offset+1] =  value &amp; 0x00FF;
    }
    if (relative) this.offset += 2;
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.index.prototype.writeInt32" id="apidoc.element.bytebuffer.index.prototype.writeInt32">
        function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>writeInt32
        <span class="apidocSignatureSpan">(value, offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeInt32 = function (value, offset) {
    var relative = typeof offset === 'undefined';
    if (relative) offset = this.offset;
    if (!this.noAssert) {
        if (typeof value !== 'number' || value % 1 !== 0)
            throw TypeError("Illegal value: "+value+" (not an integer)");
        value |= 0;
        if (typeof offset !== 'number' || offset % 1 !== 0)
            throw TypeError("Illegal offset: "+offset+" (not an integer)");
        offset &gt;&gt;&gt;= 0;
        if (offset &lt; 0 || offset + 0 &gt; this.buffer.length)
            throw RangeError("Illegal offset: 0 &lt;= "+offset+" (+"+0+") &lt;= "+this.buffer.length);
    }
    offset += 4;
    var capacity4 = this.buffer.length;
    if (offset &gt; capacity4)
        this.resize((capacity4 *= 2) &gt; offset ? capacity4 : offset);
    offset -= 4;
    if (this.littleEndian) {
        this.buffer[offset+3] = (value &gt;&gt;&gt; 24) &amp; 0xFF;
        this.buffer[offset+2] = (value &gt;&gt;&gt; 16) &amp; 0xFF;
        this.buffer[offset+1] = (value &gt;&gt;&gt;  8) &amp; 0xFF;
        this.buffer[offset  ] =  value         &amp; 0xFF;
    } else {
        this.buffer[offset  ] = (value &gt;&gt;&gt; 24) &amp; 0xFF;
        this.buffer[offset+1] = (value &gt;&gt;&gt; 16) &amp; 0xFF;
        this.buffer[offset+2] = (value &gt;&gt;&gt;  8) &amp; 0xFF;
        this.buffer[offset+3] =  value         &amp; 0xFF;
    }
    if (relative) this.offset += 4;
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.index.prototype.writeInt64" id="apidoc.element.bytebuffer.index.prototype.writeInt64">
        function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>writeInt64
        <span class="apidocSignatureSpan">(value, offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeInt64 = function (value, offset) {
    var relative = typeof offset === 'undefined';
    if (relative) offset = this.offset;
    if (!this.noAssert) {
        if (typeof value === 'number')
            value = Long.fromNumber(value);
        else if (typeof value === 'string')
            value = Long.fromString(value);
        else if (!(value &amp;&amp; value instanceof Long))
            throw TypeError("Illegal value: "+value+" (not an integer or Long)");
        if (typeof offset !== 'number' || offset % 1 !== 0)
            throw TypeError("Illegal offset: "+offset+" (not an integer)");
        offset &gt;&gt;&gt;= 0;
        if (offset &lt; 0 || offset + 0 &gt; this.buffer.length)
            throw RangeError("Illegal offset: 0 &lt;= "+offset+" (+"+0+") &lt;= "+this.buffer.length);
    }
    if (typeof value === 'number')
        value = Long.fromNumber(value);
    else if (typeof value === 'string')
        value = Long.fromString(value);
    offset += 8;
    var capacity6 = this.buffer.length;
    if (offset &gt; capacity6)
        this.resize((capacity6 *= 2) &gt; offset ? capacity6 : offset);
    offset -= 8;
    var lo = value.low,
        hi = value.high;
    if (this.littleEndian) {
        this.buffer[offset+3] = (lo &gt;&gt;&gt; 24) &amp; 0xFF;
        this.buffer[offset+2] = (lo &gt;&gt;&gt; 16) &amp; 0xFF;
        this.buffer[offset+1] = (lo &gt;&gt;&gt;  8) &amp; 0xFF;
        this.buffer[offset  ] =  lo         &amp; 0xFF;
        offset += 4;
        this.buffer[offset+3] = (hi &gt;&gt;&gt; 24) &amp; 0xFF;
        this.buffer[offset+2] = (hi &gt;&gt;&gt; 16) &amp; 0xFF;
        this.buffer[offset+1] = (hi &gt;&gt;&gt;  8) &amp; 0xFF;
        this.buffer[offset  ] =  hi         &amp; 0xFF;
    } else {
        this.buffer[offset  ] = (hi &gt;&gt;&gt; 24) &amp; 0xFF;
        this.buffer[offset+1] = (hi &gt;&gt;&gt; 16) &amp; 0xFF;
        this.buffer[offset+2] = (hi &gt;&gt;&gt;  8) &amp; 0xFF;
        this.buffer[offset+3] =  hi         &amp; 0xFF;
        offset += 4;
        this.buffer[offset  ] = (lo &gt;&gt;&gt; 24) &amp; 0xFF;
        this.buffer[offset+1] = (lo &gt;&gt;&gt; 16) &amp; 0xFF;
        this.buffer[offset+2] = (lo &gt;&gt;&gt;  8) &amp; 0xFF;
        this.buffer[offset+3] =  lo         &amp; 0xFF;
    }
    if (relative) this.offset += 8;
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.index.prototype.writeInt8" id="apidoc.element.bytebuffer.index.prototype.writeInt8">
        function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>writeInt8
        <span class="apidocSignatureSpan">(value, offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeInt8 = function (value, offset) {
    var relative = typeof offset === 'undefined';
    if (relative) offset = this.offset;
    if (!this.noAssert) {
        if (typeof value !== 'number' || value % 1 !== 0)
            throw TypeError("Illegal value: "+value+" (not an integer)");
        value |= 0;
        if (typeof offset !== 'number' || offset % 1 !== 0)
            throw TypeError("Illegal offset: "+offset+" (not an integer)");
        offset &gt;&gt;&gt;= 0;
        if (offset &lt; 0 || offset + 0 &gt; this.buffer.length)
            throw RangeError("Illegal offset: 0 &lt;= "+offset+" (+"+0+") &lt;= "+this.buffer.length);
    }
    offset += 1;
    var capacity0 = this.buffer.length;
    if (offset &gt; capacity0)
        this.resize((capacity0 *= 2) &gt; offset ? capacity0 : offset);
    offset -= 1;
    this.buffer[offset] = value;
    if (relative) this.offset += 1;
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.index.prototype.writeLong" id="apidoc.element.bytebuffer.index.prototype.writeLong">
        function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>writeLong
        <span class="apidocSignatureSpan">(value, offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeLong = function (value, offset) {
    var relative = typeof offset === 'undefined';
    if (relative) offset = this.offset;
    if (!this.noAssert) {
        if (typeof value === 'number')
            value = Long.fromNumber(value);
        else if (typeof value === 'string')
            value = Long.fromString(value);
        else if (!(value &amp;&amp; value instanceof Long))
            throw TypeError("Illegal value: "+value+" (not an integer or Long)");
        if (typeof offset !== 'number' || offset % 1 !== 0)
            throw TypeError("Illegal offset: "+offset+" (not an integer)");
        offset &gt;&gt;&gt;= 0;
        if (offset &lt; 0 || offset + 0 &gt; this.buffer.length)
            throw RangeError("Illegal offset: 0 &lt;= "+offset+" (+"+0+") &lt;= "+this.buffer.length);
    }
    if (typeof value === 'number')
        value = Long.fromNumber(value);
    else if (typeof value === 'string')
        value = Long.fromString(value);
    offset += 8;
    var capacity6 = this.buffer.length;
    if (offset &gt; capacity6)
        this.resize((capacity6 *= 2) &gt; offset ? capacity6 : offset);
    offset -= 8;
    var lo = value.low,
        hi = value.high;
    if (this.littleEndian) {
        this.buffer[offset+3] = (lo &gt;&gt;&gt; 24) &amp; 0xFF;
        this.buffer[offset+2] = (lo &gt;&gt;&gt; 16) &amp; 0xFF;
        this.buffer[offset+1] = (lo &gt;&gt;&gt;  8) &amp; 0xFF;
        this.buffer[offset  ] =  lo         &amp; 0xFF;
        offset += 4;
        this.buffer[offset+3] = (hi &gt;&gt;&gt; 24) &amp; 0xFF;
        this.buffer[offset+2] = (hi &gt;&gt;&gt; 16) &amp; 0xFF;
        this.buffer[offset+1] = (hi &gt;&gt;&gt;  8) &amp; 0xFF;
        this.buffer[offset  ] =  hi         &amp; 0xFF;
    } else {
        this.buffer[offset  ] = (hi &gt;&gt;&gt; 24) &amp; 0xFF;
        this.buffer[offset+1] = (hi &gt;&gt;&gt; 16) &amp; 0xFF;
        this.buffer[offset+2] = (hi &gt;&gt;&gt;  8) &amp; 0xFF;
        this.buffer[offset+3] =  hi         &amp; 0xFF;
        offset += 4;
        this.buffer[offset  ] = (lo &gt;&gt;&gt; 24) &amp; 0xFF;
        this.buffer[offset+1] = (lo &gt;&gt;&gt; 16) &amp; 0xFF;
        this.buffer[offset+2] = (lo &gt;&gt;&gt;  8) &amp; 0xFF;
        this.buffer[offset+3] =  lo         &amp; 0xFF;
    }
    if (relative) this.offset += 8;
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.index.prototype.writeShort" id="apidoc.element.bytebuffer.index.prototype.writeShort">
        function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>writeShort
        <span class="apidocSignatureSpan">(value, offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeShort = function (value, offset) {
    var relative = typeof offset === 'undefined';
    if (relative) offset = this.offset;
    if (!this.noAssert) {
        if (typeof value !== 'number' || value % 1 !== 0)
            throw TypeError("Illegal value: "+value+" (not an integer)");
        value |= 0;
        if (typeof offset !== 'number' || offset % 1 !== 0)
            throw TypeError("Illegal offset: "+offset+" (not an integer)");
        offset &gt;&gt;&gt;= 0;
        if (offset &lt; 0 || offset + 0 &gt; this.buffer.length)
            throw RangeError("Illegal offset: 0 &lt;= "+offset+" (+"+0+") &lt;= "+this.buffer.length);
    }
    offset += 2;
    var capacity2 = this.buffer.length;
    if (offset &gt; capacity2)
        this.resize((capacity2 *= 2) &gt; offset ? capacity2 : offset);
    offset -= 2;
    if (this.littleEndian) {
        this.buffer[offset+1] = (value &amp; 0xFF00) &gt;&gt;&gt; 8;
        this.buffer[offset  ] =  value &amp; 0x00FF;
    } else {
        this.buffer[offset]   = (value &amp; 0xFF00) &gt;&gt;&gt; 8;
        this.buffer[offset+1] =  value &amp; 0x00FF;
    }
    if (relative) this.offset += 2;
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.index.prototype.writeString" id="apidoc.element.bytebuffer.index.prototype.writeString">
        function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>writeString
        <span class="apidocSignatureSpan">(str, offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeString = function (str, offset) {
    var relative = typeof offset === 'undefined';
    if (relative) offset = this.offset;
    if (!this.noAssert) {
        if (typeof offset !== 'number' || offset % 1 !== 0)
            throw TypeError("Illegal offset: "+offset+" (not an integer)");
        offset &gt;&gt;&gt;= 0;
        if (offset &lt; 0 || offset + 0 &gt; this.buffer.length)
            throw RangeError("Illegal offset: 0 &lt;= "+offset+" (+"+0+") &lt;= "+this.buffer.length);
    }
    var k;
    k = Buffer.byteLength(str, "utf8");
    offset += k;
    var capacity14 = this.buffer.length;
    if (offset &gt; capacity14)
        this.resize((capacity14 *= 2) &gt; offset ? capacity14 : offset);
    offset -= k;
    offset += this.buffer.write(str, offset, k, "utf8");
    if (relative) {
        this.offset = offset;
        return this;
    }
    return k;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.index.prototype.writeUInt16" id="apidoc.element.bytebuffer.index.prototype.writeUInt16">
        function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>writeUInt16
        <span class="apidocSignatureSpan">(value, offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeUInt16 = function (value, offset) {
    var relative = typeof offset === 'undefined';
    if (relative) offset = this.offset;
    if (!this.noAssert) {
        if (typeof value !== 'number' || value % 1 !== 0)
            throw TypeError("Illegal value: "+value+" (not an integer)");
        value &gt;&gt;&gt;= 0;
        if (typeof offset !== 'number' || offset % 1 !== 0)
            throw TypeError("Illegal offset: "+offset+" (not an integer)");
        offset &gt;&gt;&gt;= 0;
        if (offset &lt; 0 || offset + 0 &gt; this.buffer.length)
            throw RangeError("Illegal offset: 0 &lt;= "+offset+" (+"+0+") &lt;= "+this.buffer.length);
    }
    offset += 2;
    var capacity3 = this.buffer.length;
    if (offset &gt; capacity3)
        this.resize((capacity3 *= 2) &gt; offset ? capacity3 : offset);
    offset -= 2;
    if (this.littleEndian) {
        this.buffer[offset+1] = (value &amp; 0xFF00) &gt;&gt;&gt; 8;
        this.buffer[offset  ] =  value &amp; 0x00FF;
    } else {
        this.buffer[offset]   = (value &amp; 0xFF00) &gt;&gt;&gt; 8;
        this.buffer[offset+1] =  value &amp; 0x00FF;
    }
    if (relative) this.offset += 2;
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.index.prototype.writeUInt32" id="apidoc.element.bytebuffer.index.prototype.writeUInt32">
        function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>writeUInt32
        <span class="apidocSignatureSpan">(value, offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeUInt32 = function (value, offset) {
    var relative = typeof offset === 'undefined';
    if (relative) offset = this.offset;
    if (!this.noAssert) {
        if (typeof value !== 'number' || value % 1 !== 0)
            throw TypeError("Illegal value: "+value+" (not an integer)");
        value &gt;&gt;&gt;= 0;
        if (typeof offset !== 'number' || offset % 1 !== 0)
            throw TypeError("Illegal offset: "+offset+" (not an integer)");
        offset &gt;&gt;&gt;= 0;
        if (offset &lt; 0 || offset + 0 &gt; this.buffer.length)
            throw RangeError("Illegal offset: 0 &lt;= "+offset+" (+"+0+") &lt;= "+this.buffer.length);
    }
    offset += 4;
    var capacity5 = this.buffer.length;
    if (offset &gt; capacity5)
        this.resize((capacity5 *= 2) &gt; offset ? capacity5 : offset);
    offset -= 4;
    if (this.littleEndian) {
        this.buffer[offset+3] = (value &gt;&gt;&gt; 24) &amp; 0xFF;
        this.buffer[offset+2] = (value &gt;&gt;&gt; 16) &amp; 0xFF;
        this.buffer[offset+1] = (value &gt;&gt;&gt;  8) &amp; 0xFF;
        this.buffer[offset  ] =  value         &amp; 0xFF;
    } else {
        this.buffer[offset  ] = (value &gt;&gt;&gt; 24) &amp; 0xFF;
        this.buffer[offset+1] = (value &gt;&gt;&gt; 16) &amp; 0xFF;
        this.buffer[offset+2] = (value &gt;&gt;&gt;  8) &amp; 0xFF;
        this.buffer[offset+3] =  value         &amp; 0xFF;
    }
    if (relative) this.offset += 4;
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.index.prototype.writeUInt64" id="apidoc.element.bytebuffer.index.prototype.writeUInt64">
        function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>writeUInt64
        <span class="apidocSignatureSpan">(value, offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeUInt64 = function (value, offset) {
    var relative = typeof offset === 'undefined';
    if (relative) offset = this.offset;
    if (!this.noAssert) {
        if (typeof value === 'number')
            value = Long.fromNumber(value);
        else if (typeof value === 'string')
            value = Long.fromString(value);
        else if (!(value &amp;&amp; value instanceof Long))
            throw TypeError("Illegal value: "+value+" (not an integer or Long)");
        if (typeof offset !== 'number' || offset % 1 !== 0)
            throw TypeError("Illegal offset: "+offset+" (not an integer)");
        offset &gt;&gt;&gt;= 0;
        if (offset &lt; 0 || offset + 0 &gt; this.buffer.length)
            throw RangeError("Illegal offset: 0 &lt;= "+offset+" (+"+0+") &lt;= "+this.buffer.length);
    }
    if (typeof value === 'number')
        value = Long.fromNumber(value);
    else if (typeof value === 'string')
        value = Long.fromString(value);
    offset += 8;
    var capacity7 = this.buffer.length;
    if (offset &gt; capacity7)
        this.resize((capacity7 *= 2) &gt; offset ? capacity7 : offset);
    offset -= 8;
    var lo = value.low,
        hi = value.high;
    if (this.littleEndian) {
        this.buffer[offset+3] = (lo &gt;&gt;&gt; 24) &amp; 0xFF;
        this.buffer[offset+2] = (lo &gt;&gt;&gt; 16) &amp; 0xFF;
        this.buffer[offset+1] = (lo &gt;&gt;&gt;  8) &amp; 0xFF;
        this.buffer[offset  ] =  lo         &amp; 0xFF;
        offset += 4;
        this.buffer[offset+3] = (hi &gt;&gt;&gt; 24) &amp; 0xFF;
        this.buffer[offset+2] = (hi &gt;&gt;&gt; 16) &amp; 0xFF;
        this.buffer[offset+1] = (hi &gt;&gt;&gt;  8) &amp; 0xFF;
        this.buffer[offset  ] =  hi         &amp; 0xFF;
    } else {
        this.buffer[offset  ] = (hi &gt;&gt;&gt; 24) &amp; 0xFF;
        this.buffer[offset+1] = (hi &gt;&gt;&gt; 16) &amp; 0xFF;
        this.buffer[offset+2] = (hi &gt;&gt;&gt;  8) &amp; 0xFF;
        this.buffer[offset+3] =  hi         &amp; 0xFF;
        offset += 4;
        this.buffer[offset  ] = (lo &gt;&gt;&gt; 24) &amp; 0xFF;
        this.buffer[offset+1] = (lo &gt;&gt;&gt; 16) &amp; 0xFF;
        this.buffer[offset+2] = (lo &gt;&gt;&gt;  8) &amp; 0xFF;
        this.buffer[offset+3] =  lo         &amp; 0xFF;
    }
    if (relative) this.offset += 8;
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.index.prototype.writeUInt8" id="apidoc.element.bytebuffer.index.prototype.writeUInt8">
        function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>writeUInt8
        <span class="apidocSignatureSpan">(value, offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeUInt8 = function (value, offset) {
    var relative = typeof offset === 'undefined';
    if (relative) offset = this.offset;
    if (!this.noAssert) {
        if (typeof value !== 'number' || value % 1 !== 0)
            throw TypeError("Illegal value: "+value+" (not an integer)");
        value &gt;&gt;&gt;= 0;
        if (typeof offset !== 'number' || offset % 1 !== 0)
            throw TypeError("Illegal offset: "+offset+" (not an integer)");
        offset &gt;&gt;&gt;= 0;
        if (offset &lt; 0 || offset + 0 &gt; this.buffer.length)
            throw RangeError("Illegal offset: 0 &lt;= "+offset+" (+"+0+") &lt;= "+this.buffer.length);
    }
    offset += 1;
    var capacity1 = this.buffer.length;
    if (offset &gt; capacity1)
        this.resize((capacity1 *= 2) &gt; offset ? capacity1 : offset);
    offset -= 1;
    this.buffer[offset] = value;
    if (relative) this.offset += 1;
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.index.prototype.writeUTF8String" id="apidoc.element.bytebuffer.index.prototype.writeUTF8String">
        function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>writeUTF8String
        <span class="apidocSignatureSpan">(str, offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeUTF8String = function (str, offset) {
    var relative = typeof offset === 'undefined';
    if (relative) offset = this.offset;
    if (!this.noAssert) {
        if (typeof offset !== 'number' || offset % 1 !== 0)
            throw TypeError("Illegal offset: "+offset+" (not an integer)");
        offset &gt;&gt;&gt;= 0;
        if (offset &lt; 0 || offset + 0 &gt; this.buffer.length)
            throw RangeError("Illegal offset: 0 &lt;= "+offset+" (+"+0+") &lt;= "+this.buffer.length);
    }
    var k;
    k = Buffer.byteLength(str, "utf8");
    offset += k;
    var capacity14 = this.buffer.length;
    if (offset &gt; capacity14)
        this.resize((capacity14 *= 2) &gt; offset ? capacity14 : offset);
    offset -= k;
    offset += this.buffer.write(str, offset, k, "utf8");
    if (relative) {
        this.offset = offset;
        return this;
    }
    return k;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.index.prototype.writeUint16" id="apidoc.element.bytebuffer.index.prototype.writeUint16">
        function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>writeUint16
        <span class="apidocSignatureSpan">(value, offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeUint16 = function (value, offset) {
    var relative = typeof offset === 'undefined';
    if (relative) offset = this.offset;
    if (!this.noAssert) {
        if (typeof value !== 'number' || value % 1 !== 0)
            throw TypeError("Illegal value: "+value+" (not an integer)");
        value &gt;&gt;&gt;= 0;
        if (typeof offset !== 'number' || offset % 1 !== 0)
            throw TypeError("Illegal offset: "+offset+" (not an integer)");
        offset &gt;&gt;&gt;= 0;
        if (offset &lt; 0 || offset + 0 &gt; this.buffer.length)
            throw RangeError("Illegal offset: 0 &lt;= "+offset+" (+"+0+") &lt;= "+this.buffer.length);
    }
    offset += 2;
    var capacity3 = this.buffer.length;
    if (offset &gt; capacity3)
        this.resize((capacity3 *= 2) &gt; offset ? capacity3 : offset);
    offset -= 2;
    if (this.littleEndian) {
        this.buffer[offset+1] = (value &amp; 0xFF00) &gt;&gt;&gt; 8;
        this.buffer[offset  ] =  value &amp; 0x00FF;
    } else {
        this.buffer[offset]   = (value &amp; 0xFF00) &gt;&gt;&gt; 8;
        this.buffer[offset+1] =  value &amp; 0x00FF;
    }
    if (relative) this.offset += 2;
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.index.prototype.writeUint32" id="apidoc.element.bytebuffer.index.prototype.writeUint32">
        function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>writeUint32
        <span class="apidocSignatureSpan">(value, offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeUint32 = function (value, offset) {
    var relative = typeof offset === 'undefined';
    if (relative) offset = this.offset;
    if (!this.noAssert) {
        if (typeof value !== 'number' || value % 1 !== 0)
            throw TypeError("Illegal value: "+value+" (not an integer)");
        value &gt;&gt;&gt;= 0;
        if (typeof offset !== 'number' || offset % 1 !== 0)
            throw TypeError("Illegal offset: "+offset+" (not an integer)");
        offset &gt;&gt;&gt;= 0;
        if (offset &lt; 0 || offset + 0 &gt; this.buffer.length)
            throw RangeError("Illegal offset: 0 &lt;= "+offset+" (+"+0+") &lt;= "+this.buffer.length);
    }
    offset += 4;
    var capacity5 = this.buffer.length;
    if (offset &gt; capacity5)
        this.resize((capacity5 *= 2) &gt; offset ? capacity5 : offset);
    offset -= 4;
    if (this.littleEndian) {
        this.buffer[offset+3] = (value &gt;&gt;&gt; 24) &amp; 0xFF;
        this.buffer[offset+2] = (value &gt;&gt;&gt; 16) &amp; 0xFF;
        this.buffer[offset+1] = (value &gt;&gt;&gt;  8) &amp; 0xFF;
        this.buffer[offset  ] =  value         &amp; 0xFF;
    } else {
        this.buffer[offset  ] = (value &gt;&gt;&gt; 24) &amp; 0xFF;
        this.buffer[offset+1] = (value &gt;&gt;&gt; 16) &amp; 0xFF;
        this.buffer[offset+2] = (value &gt;&gt;&gt;  8) &amp; 0xFF;
        this.buffer[offset+3] =  value         &amp; 0xFF;
    }
    if (relative) this.offset += 4;
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.index.prototype.writeUint64" id="apidoc.element.bytebuffer.index.prototype.writeUint64">
        function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>writeUint64
        <span class="apidocSignatureSpan">(value, offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeUint64 = function (value, offset) {
    var relative = typeof offset === 'undefined';
    if (relative) offset = this.offset;
    if (!this.noAssert) {
        if (typeof value === 'number')
            value = Long.fromNumber(value);
        else if (typeof value === 'string')
            value = Long.fromString(value);
        else if (!(value &amp;&amp; value instanceof Long))
            throw TypeError("Illegal value: "+value+" (not an integer or Long)");
        if (typeof offset !== 'number' || offset % 1 !== 0)
            throw TypeError("Illegal offset: "+offset+" (not an integer)");
        offset &gt;&gt;&gt;= 0;
        if (offset &lt; 0 || offset + 0 &gt; this.buffer.length)
            throw RangeError("Illegal offset: 0 &lt;= "+offset+" (+"+0+") &lt;= "+this.buffer.length);
    }
    if (typeof value === 'number')
        value = Long.fromNumber(value);
    else if (typeof value === 'string')
        value = Long.fromString(value);
    offset += 8;
    var capacity7 = this.buffer.length;
    if (offset &gt; capacity7)
        this.resize((capacity7 *= 2) &gt; offset ? capacity7 : offset);
    offset -= 8;
    var lo = value.low,
        hi = value.high;
    if (this.littleEndian) {
        this.buffer[offset+3] = (lo &gt;&gt;&gt; 24) &amp; 0xFF;
        this.buffer[offset+2] = (lo &gt;&gt;&gt; 16) &amp; 0xFF;
        this.buffer[offset+1] = (lo &gt;&gt;&gt;  8) &amp; 0xFF;
        this.buffer[offset  ] =  lo         &amp; 0xFF;
        offset += 4;
        this.buffer[offset+3] = (hi &gt;&gt;&gt; 24) &amp; 0xFF;
        this.buffer[offset+2] = (hi &gt;&gt;&gt; 16) &amp; 0xFF;
        this.buffer[offset+1] = (hi &gt;&gt;&gt;  8) &amp; 0xFF;
        this.buffer[offset  ] =  hi         &amp; 0xFF;
    } else {
        this.buffer[offset  ] = (hi &gt;&gt;&gt; 24) &amp; 0xFF;
        this.buffer[offset+1] = (hi &gt;&gt;&gt; 16) &amp; 0xFF;
        this.buffer[offset+2] = (hi &gt;&gt;&gt;  8) &amp; 0xFF;
        this.buffer[offset+3] =  hi         &amp; 0xFF;
        offset += 4;
        this.buffer[offset  ] = (lo &gt;&gt;&gt; 24) &amp; 0xFF;
        this.buffer[offset+1] = (lo &gt;&gt;&gt; 16) &amp; 0xFF;
        this.buffer[offset+2] = (lo &gt;&gt;&gt;  8) &amp; 0xFF;
        this.buffer[offset+3] =  lo         &amp; 0xFF;
    }
    if (relative) this.offset += 8;
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.index.prototype.writeUint8" id="apidoc.element.bytebuffer.index.prototype.writeUint8">
        function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>writeUint8
        <span class="apidocSignatureSpan">(value, offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeUint8 = function (value, offset) {
    var relative = typeof offset === 'undefined';
    if (relative) offset = this.offset;
    if (!this.noAssert) {
        if (typeof value !== 'number' || value % 1 !== 0)
            throw TypeError("Illegal value: "+value+" (not an integer)");
        value &gt;&gt;&gt;= 0;
        if (typeof offset !== 'number' || offset % 1 !== 0)
            throw TypeError("Illegal offset: "+offset+" (not an integer)");
        offset &gt;&gt;&gt;= 0;
        if (offset &lt; 0 || offset + 0 &gt; this.buffer.length)
            throw RangeError("Illegal offset: 0 &lt;= "+offset+" (+"+0+") &lt;= "+this.buffer.length);
    }
    offset += 1;
    var capacity1 = this.buffer.length;
    if (offset &gt; capacity1)
        this.resize((capacity1 *= 2) &gt; offset ? capacity1 : offset);
    offset -= 1;
    this.buffer[offset] = value;
    if (relative) this.offset += 1;
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.index.prototype.writeVString" id="apidoc.element.bytebuffer.index.prototype.writeVString">
        function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>writeVString
        <span class="apidocSignatureSpan">(str, offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeVString = function (str, offset) {
    var relative = typeof offset === 'undefined';
    if (relative) offset = this.offset;
    if (!this.noAssert) {
        if (typeof str !== 'string')
            throw TypeError("Illegal str: Not a string");
        if (typeof offset !== 'number' || offset % 1 !== 0)
            throw TypeError("Illegal offset: "+offset+" (not an integer)");
        offset &gt;&gt;&gt;= 0;
        if (offset &lt; 0 || offset + 0 &gt; this.buffer.length)
            throw RangeError("Illegal offset: 0 &lt;= "+offset+" (+"+0+") &lt;= "+this.buffer.length);
    }
    var start = offset,
        k, l;
    k = Buffer.byteLength(str, "utf8");
    l = ByteBuffer.calculateVarint32(k);
    offset += l+k;
    var capacity15 = this.buffer.length;
    if (offset &gt; capacity15)
        this.resize((capacity15 *= 2) &gt; offset ? capacity15 : offset);
    offset -= l+k;
    offset += this.writeVarint32(k, offset);
    offset += this.buffer.write(str, offset, k, "utf8");
    if (relative) {
        this.offset = offset;
        return this;
    }
    return offset - start;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.index.prototype.writeVarint32" id="apidoc.element.bytebuffer.index.prototype.writeVarint32">
        function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>writeVarint32
        <span class="apidocSignatureSpan">(value, offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeVarint32 = function (value, offset) {
    var relative = typeof offset === 'undefined';
    if (relative) offset = this.offset;
    if (!this.noAssert) {
        if (typeof value !== 'number' || value % 1 !== 0)
            throw TypeError("Illegal value: "+value+" (not an integer)");
        value |= 0;
        if (typeof offset !== 'number' || offset % 1 !== 0)
            throw TypeError("Illegal offset: "+offset+" (not an integer)");
        offset &gt;&gt;&gt;= 0;
        if (offset &lt; 0 || offset + 0 &gt; this.buffer.length)
            throw RangeError("Illegal offset: 0 &lt;= "+offset+" (+"+0+") &lt;= "+this.buffer.length);
    }
    var size = ByteBuffer.calculateVarint32(value),
        b;
    offset += size;
    var capacity10 = this.buffer.length;
    if (offset &gt; capacity10)
        this.resize((capacity10 *= 2) &gt; offset ? capacity10 : offset);
    offset -= size;
    value &gt;&gt;&gt;= 0;
    while (value &gt;= 0x80) {
        b = (value &amp; 0x7f) | 0x80;
        this.buffer[offset++] = b;
        value &gt;&gt;&gt;= 7;
    }
    this.buffer[offset++] = value;
    if (relative) {
        this.offset = offset;
        return this;
    }
    return size;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.index.prototype.writeVarint32ZigZag" id="apidoc.element.bytebuffer.index.prototype.writeVarint32ZigZag">
        function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>writeVarint32ZigZag
        <span class="apidocSignatureSpan">(value, offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeVarint32ZigZag = function (value, offset) {
    return this.writeVarint32(ByteBuffer.zigZagEncode32(value), offset);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.index.prototype.writeVarint64" id="apidoc.element.bytebuffer.index.prototype.writeVarint64">
        function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>writeVarint64
        <span class="apidocSignatureSpan">(value, offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeVarint64 = function (value, offset) {
    var relative = typeof offset === 'undefined';
    if (relative) offset = this.offset;
    if (!this.noAssert) {
        if (typeof value === 'number')
            value = Long.fromNumber(value);
        else if (typeof value === 'string')
            value = Long.fromString(value);
        else if (!(value &amp;&amp; value instanceof Long))
            throw TypeError("Illegal value: "+value+" (not an integer or Long)");
        if (typeof offset !== 'number' || offset % 1 !== 0)
            throw TypeError("Illegal offset: "+offset+" (not an integer)");
        offset &gt;&gt;&gt;= 0;
        if (offset &lt; 0 || offset + 0 &gt; this.buffer.length)
            throw RangeError("Illegal offset: 0 &lt;= "+offset+" (+"+0+") &lt;= "+this.buffer.length);
    }
    if (typeof value === 'number')
        value = Long.fromNumber(value, false);
    else if (typeof value === 'string')
        value = Long.fromString(value, false);
    else if (value.unsigned !== false) value = value.toSigned();
    var size = ByteBuffer.calculateVarint64(value),
        part0 = value.toInt() &gt;&gt;&gt; 0,
        part1 = value.shiftRightUnsigned(28).toInt() &gt;&gt;&gt; 0,
        part2 = value.shiftRightUnsigned(56).toInt() &gt;&gt;&gt; 0;
    offset += size;
    var capacity11 = this.buffer.length;
    if (offset &gt; capacity11)
        this.resize((capacity11 *= 2) &gt; offset ? capacity11 : offset);
    offset -= size;
    switch (size) {
        case 10: this.buffer[offset+9] = (part2 &gt;&gt;&gt;  7) &amp; 0x01;
        case 9 : this.buffer[offset+8] = size !== 9 ? (part2       ) | 0x80 : (part2       ) &amp; 0x7F;
        case 8 : this.buffer[offset+7] = size !== 8 ? (part1 &gt;&gt;&gt; 21) | 0x80 : (part1 &gt;&gt;&gt; 21) &amp; 0x7F;
        case 7 : this.buffer[offset+6] = size !== 7 ? (part1 &gt;&gt;&gt; 14) | 0x80 : (part1 &gt;&gt;&gt; 14) &amp; 0x7F;
        case 6 : this.buffer[offset+5] = size !== 6 ? (part1 &gt;&gt;&gt;  7) | 0x80 : (part1 &gt;&gt;&gt;  7) &amp; 0x7F;
        case 5 : this.buffer[offset+4] = size !== 5 ? (part1       ) | 0x80 : (part1       ) &amp; 0x7F;
        case 4 : this.buffer[offset+3] = size !== 4 ? (part0 &gt;&gt;&gt; 21) | 0x80 : (part0 &gt;&gt;&gt; 21) &amp; 0x7F;
        case 3 : this.buffer[offset+2] = size !== 3 ? (part0 &gt;&gt;&gt; 14) | 0x80 : (part0 &gt;&gt;&gt; 14) &amp; 0x7F;
        case 2 : this.buffer[offset+1] = size !== 2 ? (part0 &gt;&gt;&gt;  7) | 0x80 : (part0 &gt;&gt;&gt;  7) &amp; 0x7F;
        case 1 : this.buffer[offset  ] = size !== 1 ? (part0       ) | 0x80 : (part0       ) &amp; 0x7F;
    }
    if (relative) {
        this.offset += size;
        return this;
    } else {
        return size;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bytebuffer.index.prototype.writeVarint64ZigZag" id="apidoc.element.bytebuffer.index.prototype.writeVarint64ZigZag">
        function <span class="apidocSignatureSpan">bytebuffer.index.prototype.</span>writeVarint64ZigZag
        <span class="apidocSignatureSpan">(value, offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeVarint64ZigZag = function (value, offset) {
    return this.writeVarint64(ByteBuffer.zigZagEncode64(value), offset);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>